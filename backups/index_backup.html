<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Corrected charset -->
    <title>Platformer - VS. DINGUS THE THIRD!</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #1e1e1e;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      canvas {
        display: block;
        background: #87ceeb;
        border: 2px solid #fff;
        cursor: none;
      }
      /* NEW: Hide audio controls */
      audio {
        display: none;
      }
    </style>
  </head>
  <body>
    <canvas id="game" width="640" height="360"></canvas>
    <!-- NEW: Audio elements for soundtrack -->
    <!-- IMPORTANT: Replace these with your own .mp3 files! -->
    <audio id="bgm" src="game-music.mp3" loop></audio>
    <audio id="boss-bgm" src="boss-music.mp3" loop></audio>
    <script>
      (function () {
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        // --- NEW: Audio References ---
        const bgm = document.getElementById("bgm");
        const bossBgm = document.getElementById("boss-bgm");
        let hasUserInteracted = false;

        // --- NEW: World and Camera Constants ---
        const WORLD_WIDTH = 1920; // 3 times the canvas width
        const WORLD_HEIGHT = 720; // 2 times the canvas height
        const CAMERA_SMOOTH_FACTOR = 0.08;

        // --- Game Constants ---
        const GRAVITY = 0.5;
        const FRICTION = 0.8;
        const WALL_SLIDE_SPEED = 1.5;
        const WALL_JUMP_KICKOFF = 0;
        const MAX_WALL_JUMPS = 3;
        const DASH_SPEED = 12;
        const DASH_DURATION = 180;
        const DASH_INVINCIBILITY_DURATION = 200;
        const MAX_DASHES = 3;
        const DASH_REPLENISH_COOLDOWN = 1500;
        const PLAYER_SHOOT_COOLDOWN = 500;
        const MELEE_KNOCKBACK_FORCE = 1200;
        const MELEE_DAMAGE = 35;
        const STUN_DURATION = 1000;
        const SWORD_SWING_DURATION = 250;
        const BULLET_BOUNCES = 20;
        const ENEMY_SHOOT_COOLDOWN = 500;
        const AI_OPTIMAL_DISTANCE = 250;
        const AI_FLEE_DISTANCE = 120;
        const AI_PATROL_TIME = 2000;
        const HEALTH_PACK_DROP_CHANCE = 0.5;
        const VERTICAL_CLIMB_MIN_HEIGHT = 40;
        const WALL_CLIMB_KICKOFF = 0;
        const PATH_PREDICTION_STEPS = 120;
        const JUMP_CUT_VELOCITY = -4; // --- For variable jump height
        const ENEMY_PROJECTILE_ARMING_DISTANCE = 40; // --- Min distance for enemy self-damage

        // --- Gameplay Toggles ---
        const PLAYER_SEMI_AUTO_FIRE = true;
        const ENEMY_FRIENDLY_FIRE = false;
        const SHOTGUN_SEMI_AUTO_FIRE = true; // --- NEW
        const HITSCAN_SEMI_AUTO_FIRE = true; // --- NEW

        // --- Long Sword Constants ---
        const LONG_SWORD_DAMAGE = 150;
        const LONG_SWORD_KNOCKBACK_FORCE = 25;
        const LONG_SWORD_COOLDOWN = 0;
        const IMPACT_FRAME_DURATION = 250;

        // --- Parry Constants ---
        const PARRY_DURATION = 150;
        const PARRY_COOLDOWN = 150;

        // --- Domain Expansion Constants ---
        const DOMAIN_DURATION = 8000;
        const DOMAIN_COOLDOWN = 15000;
        const DOMAIN_RADIUS = 3000;
        const DOMAIN_DAMAGE_PER_TICK = 5;
        const DOMAIN_TICK_RATE = 100;
        const DOMAIN_ACTIVATION_KEY = "g";

        // --- NEW: Railcannon Constants ---
        const RAILCANNON_DAMAGE = 200;
        const RAILCANNON_KNOCKBACK_FORCE = 35;
        const RAILCANNON_COOLDOWN = 0; // MODIFIED to not be 0
        const RAILCANNON_BEAM_DURATION = 250; // How long the beam visual stays on screen

        // --- NEW: Hitscan Gun Constants ---
        const HITSCAN_DAMAGE = 50; // MODIFIED
        const HITSCAN_COOLDOWN = 100;

        // --- NEW: Shotgun Constants ---
        const SHOTGUN_DAMAGE_PER_PELLET = 10; // MODIFIED 10
        const SHOTGUN_PELLET_COUNT = 10;
        const SHOTGUN_SPREAD = 0.3; // Radians 0.3
        const SHOTGUN_COOLDOWN = 250;
        const SHOTGUN_PELLET_SPEED = 10;

        // --- Game State ---
        let gameState = "cutscene";
        const keys = {};
        const mousePos = { x: 0, y: 0 }; // --- MODIFIED: This is now SCREEN position
        const worldMousePos = { x: 0, y: 0 }; // --- NEW: Mouse position in world coordinates
        let isMouseDown = false;
        let waveNumber = 0;
        let enemyCountForSpawning = 1;
        let waveMessage = "";
        let lastShotTime = 0;
        let waveMessageEndTime = 0;
        let showPaths = false;
        const cameraShake = { duration: 0, magnitude: 0, endTime: 0 };
        let impactFrameState = { active: false, endTime: 0 };
        let screenFlash = { alpha: 0, decay: 0.05 };
        const cutsceneState = {
          timer: 0,
          stage: 0,
          letterboxHeight: canvas.height / 2,
          playerAlpha: 0,
          textAlpha: 0,
        };

        // --- NEW: Boss State ---
        let boss = null;
        let bossFightActive = false;

        // --- NEW: Camera State ---
        const camera = {
          x: 0,
          y: 0,
          width: canvas.width,
          height: canvas.height,
        };

        // --- Domain Expansion State ---
        let domainExpansion = {
          isActive: false,
          endTime: 0,
          lastTickTime: 0,
        };

        const player = {
          x: 50,
          y: WORLD_HEIGHT - 100, // --- MODIFIED: Start at the bottom of the new world
          width: 20,
          height: 20,
          color: "#ff0",
          dx: 0,
          dy: 0,
          speed: 3,
          jumpPower: -10,
          onGround: false,
          direction: "right",
          movementDirection: "right",
          onWall: false,
          wallJumpsRemaining: MAX_WALL_JUMPS,
          health: 100,
          maxHealth: 100,
          dashesRemaining: MAX_DASHES,
          isDashing: false,
          dashEndTime: 0,
          isInvincible: false,
          invincibilityEndTime: 0,
          lastDashReplenishTime: 0,
          weapons: ["Gun", "Long Sword", "Railcannon", "Hitscan", "Shotgun"],
          currentWeaponIndex: 0,
          longSwordCooldownEndTime: 0,
          railcannonCooldownEndTime: 0,
          hitscanCooldownEndTime: 0,
          shotgunCooldownEndTime: 0,
          isParrying: false,
          parryEndTime: 0,
          parryCooldownEndTime: 0,
          domainCooldownEndTime: 0,
        };

        let activeSwordSwing = null;

        // --- MODIFIED: Expanded platform layout for the new world ---
        const platforms = [
          // --- Floor and Walls ---
          { x: 0, y: WORLD_HEIGHT - 20, width: WORLD_WIDTH, height: 20 }, // Main floor
          { x: 0, y: 0, width: 20, height: WORLD_HEIGHT }, // Left wall
          { x: WORLD_WIDTH - 20, y: 0, width: 20, height: WORLD_HEIGHT }, // Right wall

          // --- Starting Area ---
          { x: 80, y: WORLD_HEIGHT - 80, width: 120, height: 15 },
          { x: 250, y: WORLD_HEIGHT - 120, width: 100, height: 15 },
          { x: 150, y: WORLD_HEIGHT - 180, width: 30, height: 60 },

          // --- Middle Section (horizontal) ---
          { x: 400, y: WORLD_HEIGHT - 160, width: 80, height: 15 },
          { x: 520, y: WORLD_HEIGHT - 210, width: 100, height: 15 },
          { x: 680, y: WORLD_HEIGHT - 180, width: 150, height: 15 },
          { x: 900, y: WORLD_HEIGHT - 150, width: 200, height: 15 },
          { x: 850, y: WORLD_HEIGHT - 250, width: 30, height: 100 }, // vertical pillar
          { x: 1150, y: WORLD_HEIGHT - 220, width: 100, height: 15 },

          // --- Upper Vertical Section ---
          { x: 280, y: WORLD_HEIGHT - 250, width: 120, height: 15 },
          { x: 450, y: WORLD_HEIGHT - 300, width: 30, height: 150 }, // tall wall
          { x: 550, y: WORLD_HEIGHT - 350, width: 150, height: 15 },
          { x: 600, y: WORLD_HEIGHT - 450, width: 15, height: 100 }, // hanging pillar
          { x: 400, y: WORLD_HEIGHT - 500, width: 100, height: 15 },
          { x: 200, y: WORLD_HEIGHT - 550, width: 150, height: 15 },
          { x: 80, y: WORLD_HEIGHT - 480, width: 80, height: 15 },

          // --- Right Side of the Map ---
          { x: 1300, y: WORLD_HEIGHT - 80, width: 200, height: 15 },
          { x: 1550, y: WORLD_HEIGHT - 150, width: 150, height: 15 },
          { x: 1750, y: WORLD_HEIGHT - 220, width: 150, height: 15 },
          { x: 1600, y: WORLD_HEIGHT - 300, width: 100, height: 15 },
          { x: 1400, y: WORLD_HEIGHT - 380, width: 120, height: 15 },
          { x: 1200, y: WORLD_HEIGHT - 450, width: 150, height: 15 },
          { x: 1000, y: WORLD_HEIGHT - 520, width: 100, height: 15 },

          // --- Floating high platforms ---
          { x: 700, y: 150, width: 120, height: 15 },
          { x: 900, y: 100, width: 100, height: 15 },
          { x: 1100, y: 180, width: 80, height: 15 },
        ];
        const enemies = [];
        const pellets = [];
        const enemyPellets = [];
        const particles = [];
        const healthPacks = [];
        const slashEffects = [];
        const activeBeams = [];
        // --- MODIFIED: Spawn points for the new world ---
        const spawnPoints = [
          { x: 425, y: WORLD_HEIGHT - 220 },
          { x: 150, y: WORLD_HEIGHT - 100 },
          { x: 950, y: WORLD_HEIGHT - 200 },
          { x: 250, y: WORLD_HEIGHT - 600 },
          { x: 1600, y: WORLD_HEIGHT - 100 },
          { x: 1700, y: WORLD_HEIGHT - 300 },
          { x: 800, y: 100 },
        ];
        // --- NEW: Music Control Functions ---
        function playMusic(track) {
          track.volume = 0.5;
          const promise = track.play();
          if (promise !== undefined) {
            promise.catch((error) => {
              console.error("Audio play failed:", error);
            });
          }
        }

        function stopMusic(track) {
          track.pause();
          track.currentTime = 0;
        }

        function handleFirstInteraction() {
          if (!hasUserInteracted) {
            hasUserInteracted = true;
            playMusic(bgm);
          }
        }

        function spawnEnemies(count) {
          for (let i = 0; i < count; i++) {
            const spawnPoint = spawnPoints[i % spawnPoints.length];
            enemies.push({
              x: spawnPoint.x,
              y: spawnPoint.y,
              width: 20,
              height: 20,
              color: "#f00",
              dx: 0,
              dy: 0,
              speed: 2.1,
              jumpPower: -10,
              onGround: false,
              direction: "left",
              onWall: false,
              wallJumpsRemaining: MAX_WALL_JUMPS,
              shootCooldown: ENEMY_SHOOT_COOLDOWN,
              lastShotTime: 0,
              health: 100,
              maxHealth: 100,
              isStunned: false,
              stunEndTime: 0,
              aiState: "patrolling",
              lastKnownPlayerPos: null,
              currentPlatform: null,
              aiStateTimer: 0,
              patrolDirection: 1,
              isMidClimb: false,
              isVerticalClimbing: false,
              climbingWall: null,
              climbDirection: 0,
              targetPos: null,
              pathPrediction: [],
              wallClimbCount: 0,
              isDying: false,
              deathTimer: 0,
            });
          }
        }

        // --- NEW: Boss spawning function ---
        function spawnBoss() {
          bossFightActive = true;
          boss = {
            name: "Dingus the Third",
            x: WORLD_WIDTH / 2 - 50,
            y: 100,
            width: 60,
            height: 60,
            color: "#8B008B", // Dark Magenta
            dx: 0,
            dy: 0,
            onGround: false,
            health: 5000,
            maxHealth: 5000,
            aiState: "intro", // Intro animation
            aiTimer: Date.now() + 3000, // 3 seconds for intro
            attackPhase: 0,
            attackAngle: 0, // For spiral attack
            isInvincible: true,
            isDying: false,
            deathTimer: 0,
          };
          stopMusic(bgm);
          playMusic(bossBgm);
          waveMessage = `BOSS: DINGUS THE THIRD`;
          waveMessageEndTime = Date.now() + 4000;
        }

        function spawnParticles(x, y, count, color, magnitude = 3) {
          for (let i = 0; i < count; i++) {
            particles.push({
              x,
              y,
              dx: (Math.random() - 0.5) * magnitude,
              dy: (Math.random() - 0.5) * magnitude,
              size: Math.random() * 3 + 1,
              color,
              life: 30,
            });
          }
        }

        function createSlashEffect(x, y) {
          const angle = Math.random() * Math.PI * 2;
          const length = 20 + Math.random() * 20;
          slashEffects.push({
            x,
            y,
            angle,
            length,
            life: 15, // lasts for 15 frames
            alpha: 1.0,
          });
        }

        function triggerCameraShake(duration, magnitude) {
          cameraShake.duration = duration;
          cameraShake.magnitude = magnitude;
          cameraShake.endTime = Date.now() + duration;
        }

        function triggerImpactFrame(duration) {
          impactFrameState.active = true;
          impactFrameState.endTime = Date.now() + duration;
          screenFlash.alpha = 0.8;
        }

        function shootPellet() {
          const now = Date.now();
          if (!PLAYER_SEMI_AUTO_FIRE) {
            if (now - lastShotTime < PLAYER_SHOOT_COOLDOWN) return;
          }
          lastShotTime = now;
          const playerCenterX = player.x + player.width / 2;
          const playerCenterY = player.y + player.height / 2;
          let dx = worldMousePos.x - playerCenterX,
            dy = worldMousePos.y - playerCenterY;
          const magnitude = Math.sqrt(dx * dx + dy * dy) || 1;
          const bulletSpeed = 7;
          pellets.push({
            x: playerCenterX,
            y: playerCenterY,
            dx: (dx / magnitude) * bulletSpeed,
            dy: (dy / magnitude) * bulletSpeed,
            radius: 4,
            color: "#000",
            bounces: BULLET_BOUNCES,
            damage: 10,
          });
        }

        function fireHitscan() {
          const now = Date.now();
          if (now < player.hitscanCooldownEndTime) return;
          player.hitscanCooldownEndTime = now + HITSCAN_COOLDOWN;

          const startPos = {
            x: player.x + player.width / 2,
            y: player.y + player.height / 2,
          };
          const dir = {
            x: worldMousePos.x - startPos.x,
            y: worldMousePos.y - startPos.y,
          };
          const mag = Math.hypot(dir.x, dir.y) || 1;
          dir.x /= mag;
          dir.y /= mag;

          // 1. Define a long ray
          const rayEndPos = {
            x: startPos.x + dir.x * WORLD_WIDTH * 2,
            y: startPos.y + dir.y * WORLD_WIDTH * 2,
          };

          // 2. Find the first wall hit point
          let closestWallHit = { dist: Infinity, point: rayEndPos };
          for (const plat of platforms) {
            const hitPoint = getLineRectIntersection(startPos, rayEndPos, plat);
            if (hitPoint) {
              const dist = Math.hypot(
                hitPoint.x - startPos.x,
                hitPoint.y - startPos.y
              );
              if (dist < closestWallHit.dist) {
                closestWallHit.dist = dist;
                closestWallHit.point = hitPoint;
              }
            }
          }

          let beamEndPoint = closestWallHit.point; // Default end point is the wall

          // 3. Find the closest enemy hit *before* the wall
          let allTargets = enemies.slice();
          if (boss && !boss.isInvincible) allTargets.push(boss);

          let closestTargetHit = { target: null, dist: Infinity, point: null };
          for (const target of allTargets) {
            if (target.isDying) continue;
            const hitPoint = getLineRectIntersection(
              startPos,
              rayEndPos,
              target
            );
            if (hitPoint) {
              const dist = Math.hypot(
                hitPoint.x - startPos.x,
                hitPoint.y - startPos.y
              );
              // Check if this enemy is closer than other enemies AND closer than the wall
              if (dist < closestTargetHit.dist && dist < closestWallHit.dist) {
                closestTargetHit = { target, dist, point: hitPoint };
              }
            }
          }

          // 4. Apply damage and update beam end point if an enemy was hit
          if (closestTargetHit.target) {
            closestTargetHit.target.health -= HITSCAN_DAMAGE;
            spawnParticles(
              closestTargetHit.point.x,
              closestTargetHit.point.y,
              5,
              "#ff0000"
            );
            if (
              closestTargetHit.target.health <= 0 &&
              !closestTargetHit.target.isDying
            ) {
              closestTargetHit.target.health = 0;
              closestTargetHit.target.isDying = true;
              closestTargetHit.target.deathTimer = now + 1000;
            }
            beamEndPoint = closestTargetHit.point; // Update beam to stop at the enemy
          } else {
            // If we hit a wall, spawn particles there
            if (closestWallHit.dist < Infinity) {
              spawnParticles(
                closestWallHit.point.x,
                closestWallHit.point.y,
                5,
                "#aaaaaa"
              );
            }
          }

          // 5. Create the visual beam
          activeBeams.push({
            start: startPos,
            end: beamEndPoint,
            endTime: now + 100,
            alpha: 1.0,
            color: "rgba(255, 255, 0, 0.8)",
            width: 2,
          });
        }

        function fireShotgun() {
          const now = Date.now();
          if (now < player.shotgunCooldownEndTime) return;
          player.shotgunCooldownEndTime = now + SHOTGUN_COOLDOWN;

          const playerCenterX = player.x + player.width / 2;
          const playerCenterY = player.y + player.height / 2;
          let dx = worldMousePos.x - playerCenterX,
            dy = worldMousePos.y - playerCenterY;
          const baseAngle = Math.atan2(dy, dx);

          for (let i = 0; i < SHOTGUN_PELLET_COUNT; i++) {
            const angle = baseAngle + (Math.random() - 0.5) * SHOTGUN_SPREAD;
            pellets.push({
              x: playerCenterX,
              y: playerCenterY,
              dx: Math.cos(angle) * SHOTGUN_PELLET_SPEED,
              dy: Math.sin(angle) * SHOTGUN_PELLET_SPEED,
              radius: 2,
              color: "#333",
              bounces: 0,
              damage: SHOTGUN_DAMAGE_PER_PELLET,
              life: 30, // Pellets disappear after a short time
            });
          }
          triggerCameraShake(150, 5);
        }

        // --- MODIFIED: Railcannon Firing Logic ---
        function fireRailcannon() {
          const now = Date.now();
          if (now < player.railcannonCooldownEndTime) return;

          player.railcannonCooldownEndTime = now + RAILCANNON_COOLDOWN;
          triggerCameraShake(300, 15);
          triggerImpactFrame(50);

          const startPos = {
            x: player.x + player.width / 2,
            y: player.y + player.height / 2,
          };
          const dir = {
            x: worldMousePos.x - startPos.x,
            y: worldMousePos.y - startPos.y,
          };
          const mag = Math.hypot(dir.x, dir.y) || 1;
          dir.x /= mag;
          dir.y /= mag;

          // Define a very long ray for both damage and visuals.
          const endPoint = {
            x: startPos.x + dir.x * WORLD_WIDTH * 2,
            y: startPos.y + dir.y * WORLD_WIDTH * 2,
          };

          // Find the first wall hit point, but ONLY for the particle effect.
          let closestWallHit = { dist: Infinity, point: endPoint };
          for (const plat of platforms) {
            const hitPoint = getLineRectIntersection(startPos, endPoint, plat);
            if (hitPoint) {
              const dist = Math.hypot(
                hitPoint.x - startPos.x,
                hitPoint.y - startPos.y
              );
              if (dist < closestWallHit.dist) {
                closestWallHit.dist = dist;
                closestWallHit.point = hitPoint;
              }
            }
          }
          const particleImpactPoint = closestWallHit.point;

          // Check for targets hit along the full ray.
          let allTargets = enemies.slice();
          if (boss && !boss.isInvincible) allTargets.push(boss);

          const hitTargets = [];
          for (const target of allTargets) {
            if (target.isDying) continue;
            if (lineIntersectsRect(startPos, endPoint, target)) {
              hitTargets.push(target);
            }
          }

          // Apply effects to all hit targets.
          for (const target of hitTargets) {
            target.health -= RAILCANNON_DAMAGE;

            // Stun only regular enemies
            if (!target.name) {
              // A simple check if it's not the boss
              target.isStunned = true;
              target.stunEndTime = now + STUN_DURATION;
            }

            const knockbackDir = {
              x: target.x + target.width / 2 - startPos.x,
              y: target.y + target.height / 2 - startPos.y,
            };
            const knockbackMag =
              Math.hypot(knockbackDir.x, knockbackDir.y) || 1;
            target.dx =
              (knockbackDir.x / knockbackMag) * RAILCANNON_KNOCKBACK_FORCE;
            target.dy =
              ((knockbackDir.y / knockbackMag) * RAILCANNON_KNOCKBACK_FORCE) /
                2 -
              5;

            spawnParticles(
              target.x + target.width / 2,
              target.y + target.height / 2,
              40,
              "#00ffff",
              10
            );

            if (target.health <= 0 && !target.isDying) {
              target.health = 0;
              target.isDying = true;
              target.deathTimer = now + 1000;
            }
          }

          // The visual beam now uses the long-distance endPoint to appear to go through walls.
          activeBeams.push({
            start: startPos,
            end: endPoint,
            endTime: now + RAILCANNON_BEAM_DURATION,
            alpha: 1.0,
            color: "rgba(0, 255, 255, 0.8)",
            width: 20,
          });

          // The impact particles, however, should still appear at the first physical surface hit.
          spawnParticles(
            particleImpactPoint.x,
            particleImpactPoint.y,
            60,
            "#ffff00",
            8
          );
        }

        function performDash() {
          if (player.dashesRemaining <= 0 || player.isDashing) return;
          player.dashesRemaining--;
          player.isDashing = true;
          player.isInvincible = true;
          player.dashEndTime = Date.now() + DASH_DURATION;
          player.invincibilityEndTime =
            Date.now() + DASH_INVINCIBILITY_DURATION;
          player.dx =
            player.movementDirection === "right" ? DASH_SPEED : -DASH_SPEED;
          player.dy = 0;
        }

        function performParry() {
          const now = Date.now();
          if (player.isParrying || now < player.parryCooldownEndTime) return;

          player.isParrying = true;
          player.parryEndTime = now + PARRY_DURATION;
          player.parryCooldownEndTime = now + PARRY_COOLDOWN;

          spawnParticles(
            player.x + player.width / 2,
            player.y + player.height / 2,
            5,
            "#00ffff",
            2
          );
        }

        function performDomainExpansion() {
          const now = Date.now();
          if (domainExpansion.isActive || now < player.domainCooldownEndTime)
            return;

          domainExpansion.isActive = true;
          domainExpansion.endTime = now + DOMAIN_DURATION;
          player.domainCooldownEndTime = now + DOMAIN_COOLDOWN;
          domainExpansion.lastTickTime = now;

          triggerCameraShake(500, 15);
          screenFlash.alpha = 0.9;
          spawnParticles(
            player.x + player.width / 2,
            player.y + player.height / 2,
            100,
            "#8B0000",
            10
          );
        }

        function performMeleeAttack() {
          if (activeSwordSwing) return;

          const now = Date.now();
          const currentWeapon = player.weapons[player.currentWeaponIndex];
          const centerX = player.x + player.width / 2;
          const centerY = player.y + player.height / 2;
          const dxToMouse = worldMousePos.x - centerX;
          const dyToMouse = worldMousePos.y - centerY;
          const angle = Math.atan2(dyToMouse, dxToMouse);

          if (currentWeapon === "Sword") {
            activeSwordSwing = {
              startTime: now,
              duration: SWORD_SWING_DURATION,
              startAngle: angle - 1.0,
              endAngle: angle + 1.0,
              hitTargets: [],
              weaponType: "Sword",
            };
          } else if (currentWeapon === "Long Sword") {
            if (now < player.longSwordCooldownEndTime) return;

            player.longSwordCooldownEndTime = now + LONG_SWORD_COOLDOWN;
            activeSwordSwing = {
              startTime: now,
              duration: SWORD_SWING_DURATION + 100,
              startAngle: angle - 1.5,
              endAngle: angle + 1.5,
              hitTargets: [],
              weaponType: "Long Sword",
            };
          }
        }

        function skipCutscene() {
          if (gameState === "cutscene") {
            gameState = "playing";
            cutsceneState.stage = 3;
            handleFirstInteraction(); // Start music if skipped
          }
        }

        function predictPath(enemy, steps = PATH_PREDICTION_STEPS) {
          if (!enemy.targetPos) return [];
          const path = [];
          let simulatedEnemy = { ...enemy };
          simulatedEnemy.pathPrediction = [];
          for (let i = 0; i < steps; i++) {
            path.push({ x: simulatedEnemy.x, y: simulatedEnemy.y });
            simulatedEnemy.dy += GRAVITY;
            const toTargetX = simulatedEnemy.targetPos.x - simulatedEnemy.x;
            if (Math.abs(toTargetX) > 5) {
              simulatedEnemy.dx += Math.sign(toTargetX) * 0.1;
              if (Math.abs(simulatedEnemy.dx) > simulatedEnemy.speed) {
                simulatedEnemy.dx =
                  Math.sign(simulatedEnemy.dx) * simulatedEnemy.speed;
              }
            } else {
              simulatedEnemy.dx *= FRICTION;
            }
            if (
              simulatedEnemy.onWall &&
              simulatedEnemy.dy > 0 &&
              !simulatedEnemy.onGround
            ) {
              simulatedEnemy.dy = WALL_SLIDE_SPEED;
            }
            let nextX = simulatedEnemy.x + simulatedEnemy.dx;
            let nextY = simulatedEnemy.y + simulatedEnemy.dy;
            simulatedEnemy.onGround = false;
            simulatedEnemy.onWall = false;
            for (const plat of platforms) {
              if (checkCollision({ ...simulatedEnemy, x: nextX }, plat)) {
                if (simulatedEnemy.dx > 0) {
                  nextX = plat.x - simulatedEnemy.width;
                  simulatedEnemy.onWall = "right";
                } else if (simulatedEnemy.dx < 0) {
                  nextX = plat.x + plat.width;
                  simulatedEnemy.onWall = "left";
                }
                simulatedEnemy.dx = 0;
              }
              if (checkCollision({ ...simulatedEnemy, y: nextY }, plat)) {
                if (simulatedEnemy.dy > 0) {
                  nextY = plat.y - simulatedEnemy.height;
                  simulatedEnemy.onGround = true;
                  simulatedEnemy.dy = 0;
                } else if (simulatedEnemy.dy < 0) {
                  nextY = plat.y + plat.height;
                  simulatedEnemy.dy = 0;
                }
              }
            }
            simulatedEnemy.x = nextX;
            simulatedEnemy.y = nextY;
            if (
              simulatedEnemy.onWall &&
              !simulatedEnemy.onGround &&
              simulatedEnemy.targetPos.y < simulatedEnemy.y
            ) {
              simulatedEnemy.dy = simulatedEnemy.jumpPower;
              simulatedEnemy.dx = simulatedEnemy.onWall === "left" ? 1 : -1;
            } else if (
              simulatedEnemy.onGround &&
              simulatedEnemy.targetPos.y < simulatedEnemy.y - 10
            ) {
              simulatedEnemy.dy = simulatedEnemy.jumpPower;
              simulatedEnemy.onGround = false;
            }
            if (simulatedEnemy.x < 0) simulatedEnemy.x = 0;
            if (simulatedEnemy.x + simulatedEnemy.width > WORLD_WIDTH) {
              simulatedEnemy.x = WORLD_WIDTH - simulatedEnemy.width;
            }
          }
          return path;
        }

        canvas.addEventListener("mousemove", (e) => {
          const rect = canvas.getBoundingClientRect();
          mousePos.x = e.clientX - rect.left;
          mousePos.y = e.clientY - rect.top;
        });
        canvas.addEventListener("mousedown", (e) => {
          handleFirstInteraction();
          if (e.button === 0) {
            isMouseDown = true;
            if (gameState === "playing") {
              const currentWeapon = player.weapons[player.currentWeaponIndex];
              if (currentWeapon === "Gun" && PLAYER_SEMI_AUTO_FIRE) {
                shootPellet();
              } else if (currentWeapon === "Railcannon") {
                fireRailcannon();
              } else if (
                currentWeapon === "Hitscan" &&
                HITSCAN_SEMI_AUTO_FIRE
              ) {
                fireHitscan();
              } else if (
                currentWeapon === "Shotgun" &&
                SHOTGUN_SEMI_AUTO_FIRE
              ) {
                fireShotgun();
              }
            }
          }
          if (e.button === 2) {
            if (gameState === "playing") {
              performParry();
            }
          }
        });
        canvas.addEventListener("contextmenu", (e) => e.preventDefault());

        window.addEventListener("mouseup", (e) => {
          if (e.button === 0) isMouseDown = false;
        });

        window.addEventListener("keydown", (e) => {
          const key = e.key.toLowerCase();

          handleFirstInteraction();

          if (key === "escape") {
            if (gameState === "playing") {
              gameState = "paused";
            } else if (gameState === "paused") {
              gameState = "playing";
            }
          }

          skipCutscene();
          keys[key] = true;
          if (key === "n") {
            enemyCountForSpawning++;
          }
          if (key === "m") {
            enemyCountForSpawning = Math.max(1, enemyCountForSpawning - 1);
          }
          if (gameState !== "playing") return;
          if (key === "p" && !keys.pPressed) {
            showPaths = !showPaths;
            keys.pPressed = true;
          }
          if (key === "q") {
            player.currentWeaponIndex =
              (player.currentWeaponIndex + 1) % player.weapons.length;
          }
          if (key === DOMAIN_ACTIVATION_KEY) {
            performDomainExpansion();
          }
          if (key === "w") {
            if (player.onGround) {
              player.dy = player.jumpPower;
              player.onGround = false;
            } else if (player.onWall && player.wallJumpsRemaining > 0) {
              player.dy = player.jumpPower;
              player.dx =
                player.onWall === "left"
                  ? WALL_JUMP_KICKOFF
                  : -WALL_JUMP_KICKOFF;
              player.wallJumpsRemaining--;
              player.onWall = false;
            }
          }
          if (key === "shift") performDash();
        });

        window.addEventListener("keyup", (e) => {
          const key = e.key.toLowerCase();
          keys[key] = false;
          if (key === "p") keys.pPressed = false;

          if (key === "w") {
            if (player.dy < 0) {
              player.dy = Math.max(player.dy, JUMP_CUT_VELOCITY);
            }
          }
        });

        function checkCollision(objA, objB) {
          return (
            objA.x < objB.x + objB.width &&
            objA.x + objA.width > objB.x &&
            objA.y < objB.y + objB.height &&
            objA.y + objA.height > objB.y
          );
        }
        function hasLineOfSight(posA, posB) {
          for (const plat of platforms)
            if (lineIntersectsRect(posA, posB, plat)) return false;
          return true;
        }
        function lineIntersectsRect(p1, p2, rect) {
          function lineIntersectsLine(p1, p2, p3, p4) {
            const den =
              (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (den === 0) return false;
            const t =
              ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) /
              den;
            const u =
              -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) /
              den;
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
          }
          const { x, y, width, height } = rect;
          const rectTopLeft = { x, y };
          const rectTopRight = { x: x + width, y };
          const rectBottomLeft = { x, y: y + height };
          const rectBottomRight = { x: x + width, y: y + height };

          if (lineIntersectsLine(p1, p2, rectTopLeft, rectTopRight))
            return true;
          if (lineIntersectsLine(p1, p2, rectTopRight, rectBottomRight))
            return true;
          if (lineIntersectsLine(p1, p2, rectBottomRight, rectBottomLeft))
            return true;
          if (lineIntersectsLine(p1, p2, rectBottomLeft, rectTopLeft))
            return true;

          const isP1Inside =
            p1.x >= x && p1.x <= x + width && p1.y >= y && p1.y <= y + height;
          if (isP1Inside) return true;

          return false;
        }

        function getLineRectIntersection(p1, p2, rect) {
          const { x, y, width, height } = rect;
          const lines = [
            [
              { x: x, y: y },
              { x: x + width, y: y },
            ], // Top
            [
              { x: x, y: y },
              { x: x, y: y + height },
            ], // Left
            [
              { x: x + width, y: y },
              { x: x + width, y: y + height },
            ], // Right
            [
              { x: x, y: y + height },
              { x: x + width, y: y + height },
            ], // Bottom
          ];

          let closestIntersection = null;
          let minDistance = Infinity;

          for (const line of lines) {
            const p3 = line[0];
            const p4 = line[1];

            const den =
              (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (den === 0) continue;

            const t =
              ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) /
              den;
            const u =
              -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) /
              den;

            if (t > 0 && t < 1 && u > 0 && u < 1) {
              const intersectPoint = {
                x: p1.x + t * (p2.x - p1.x),
                y: p1.y + t * (p2.y - p1.y),
              };
              const dist = Math.hypot(
                intersectPoint.x - p1.x,
                intersectPoint.y - p1.y
              );

              if (dist < minDistance) {
                minDistance = dist;
                closestIntersection = intersectPoint;
              }
            }
          }
          return closestIntersection;
        }

        function resetPlayer() {
          player.x = 50;
          player.y = WORLD_HEIGHT - 100;
          player.dx = 0;
          player.dy = 0;
          player.wallJumpsRemaining = MAX_WALL_JUMPS;
          player.onGround = false;
          player.health = player.maxHealth;
          player.direction = "right";
          player.movementDirection = "right";
          player.dashesRemaining = MAX_DASHES;
          player.isDashing = false;
          player.isInvincible = false;
          player.lastDashReplenishTime = Date.now();
        }

        const AI_CFG = {
          accel: 0.6,
          airAccel: 0.3,
          maxSpeed: 2.5,
          patrolSpeedFactor: 0.5,
          friction: 0.85,
          jumpBufferMs: 140,
          coyoteMs: 120,
          edgeLookAhead: 28,
          takeoffMargin: 6,
          gapMaxJumpDist: 170,
          maxUpJumpHeight: 90,
          climbIntervalMs: 140,
          climbApexVel: -0.25,
          maxWallJumps: 12,
          wallClimbKickX:
            typeof WALL_CLIMB_KICKOFF !== "undefined"
              ? WALL_CLIMB_KICKOFF
              : 0.4,
          wallJumpKickX:
            typeof WALL_JUMP_KICKOFF !== "undefined" ? WALL_JUMP_KICKOFF : 2.1,
          planCooldownMs: 250,
          waypointArriveDist: 8,
          platformGraphRebuildMs: 1000,
        };

        const AI_NAV_CACHE = {
          graph: null,
          lastBuildTime: 0,
        };
        function ensureAIProps(enemy, now) {
          if (enemy._aiInited) return;
          enemy._aiInited = true;
          enemy.maxSpeed = enemy.maxSpeed || AI_CFG.maxSpeed;
          enemy.accel = enemy.accel || AI_CFG.accel;
          enemy.airAccel = enemy.airAccel || AI_CFG.airAccel;
          enemy.friction = enemy.friction || AI_CFG.friction;
          enemy.lastGroundTime = now;
          enemy.lastWallTime = -1;
          enemy.jumpQueuedUntil = -1;
          enemy.aiStateTimer =
            now +
            (typeof AI_PATROL_TIME !== "undefined" ? AI_PATROL_TIME : 1500);
          enemy.wallClimb = {
            active: false,
            lastJumpTime: -1,
            side: null,
            jumpsLeft: AI_CFG.maxWallJumps,
            wallRef: null,
          };
          enemy.nav = {
            path: [],
            idx: 0,
            goalPlatformId: null,
            lastPlanTime: 0,
            lastGoal: null,
          };
          enemy.patrolDirection = enemy.patrolDirection || 1;
        }
        function buildPlatformGraph(platforms, now) {
          if (
            AI_NAV_CACHE.graph &&
            now - AI_NAV_CACHE.lastBuildTime < AI_CFG.platformGraphRebuildMs
          )
            return AI_NAV_CACHE.graph;
          const nodes = platforms.map((p, i) => ({ id: i, p }));
          const edges = new Map();
          function addEdge(a, b, type, meta = {}) {
            if (!edges.has(a)) edges.set(a, []);
            edges.get(a).push({ to: b, type, ...meta });
          }
          for (let i = 0; i < platforms.length; i++) {
            const A = platforms[i];
            const aLeft = A.x,
              aRight = A.x + A.width,
              aTop = A.y;
            for (let j = 0; j < platforms.length; j++) {
              if (i === j) continue;
              const B = platforms[j];
              const bLeft = B.x,
                bRight = B.x + B.width,
                bTop = B.y;
              const verticalDelta = bTop - aTop;
              const overlap = !(aRight < bLeft || bRight < aLeft);
              if (verticalDelta > 0 && overlap) {
                addEdge(i, j, "drop", {
                  xHint: clamp(
                    (Math.max(aLeft, bLeft) + Math.min(aRight, bRight)) / 2,
                    aLeft + 8,
                    aRight - 8
                  ),
                });
              }
              const dxRight = Math.max(0, bLeft - aRight);
              const dxLeft = Math.max(0, aLeft - bRight);
              const dx = Math.min(dxRight, dxLeft);
              if (
                Math.abs(verticalDelta) <= AI_CFG.maxUpJumpHeight + 12 &&
                dx <= AI_CFG.gapMaxJumpDist
              ) {
                if (bLeft >= aRight) {
                  addEdge(i, j, "jump", {
                    fromSide: "right",
                    takeoffX: aRight - AI_CFG.takeoffMargin,
                  });
                } else if (bRight <= aLeft) {
                  addEdge(i, j, "jump", {
                    fromSide: "left",
                    takeoffX: aLeft + AI_CFG.takeoffMargin,
                  });
                } else if (overlap && verticalDelta < 0) {
                  addEdge(i, j, "jump", {
                    fromSide: "center",
                    takeoffX: clamp(
                      (Math.max(aLeft, bLeft) + Math.min(aRight, bRight)) / 2,
                      aLeft + 12,
                      aRight - 12
                    ),
                  });
                }
              }
            }
          }
          AI_NAV_CACHE.graph = { nodes, edges };
          AI_NAV_CACHE.lastBuildTime = now;
          return AI_NAV_CACHE.graph;
        }
        function platformIdAt(x, y, platforms) {
          for (let i = 0; i < platforms.length; i++) {
            const p = platforms[i];
            if (
              x >= p.x &&
              x <= p.x + p.width &&
              Math.abs(y - p.y) < 2_000 /* coarse */
            ) {
              return i;
            }
          }
          return null;
        }
        function bfsPlatforms(graph, startId, goalId) {
          if (startId === null || goalId === null) return null;
          if (startId === goalId) return [];
          const q = [startId];
          const prev = new Map();
          const seen = new Set([startId]);
          while (q.length) {
            const cur = q.shift();
            const neighbors = graph.edges.get(cur) || [];
            for (const e of neighbors) {
              if (seen.has(e.to)) continue;
              seen.add(e.to);
              prev.set(e.to, { from: cur, edge: e });
              if (e.to === goalId) {
                const steps = [];
                let node = goalId;
                while (node !== startId) {
                  const info = prev.get(node);
                  steps.push(info.edge);
                  node = info.from;
                }
                return steps.reverse();
              }
              q.push(e.to);
            }
          }
          return null;
        }
        function planPath(enemy, targetPos, now, platforms) {
          const graph = buildPlatformGraph(platforms, now);
          const enemyFootY = enemy.y + enemy.height;
          const enemyPlatId = enemy.currentPlatform
            ? platforms.indexOf(enemy.currentPlatform)
            : platformIdAt(enemy.x + enemy.width / 2, enemyFootY, platforms);
          const goalPlatId = platformIdAt(
            targetPos.x,
            targetPos.y + (enemy.height || 0),
            platforms
          );
          if (enemyPlatId === null || goalPlatId === null) {
            enemy.nav.path = [];
            enemy.nav.idx = 0;
            enemy.nav.goalPlatformId = null;
            return;
          }
          if (
            enemy.nav.goalPlatformId === goalPlatId &&
            now - enemy.nav.lastPlanTime < AI_CFG.planCooldownMs
          )
            return;
          const steps = bfsPlatforms(graph, enemyPlatId, goalPlatId);
          enemy.nav.path = steps || [];
          enemy.nav.idx = 0;
          enemy.nav.goalPlatformId = goalPlatId;
          enemy.nav.lastPlanTime = now;
        }
        function currentWaypoint(enemy, platforms, fallbackPos) {
          if (!enemy.nav.path || enemy.nav.idx >= enemy.nav.path.length) {
            return fallbackPos || null;
          }
          const step = enemy.nav.path[enemy.nav.idx];
          const curPlat = enemy.currentPlatform;
          if (!curPlat) return fallbackPos || null;
          const curPlatLeft = curPlat.x,
            curPlatRight = curPlat.x + curPlat.width;
          switch (step.type) {
            case "drop": {
              const xTarget = clamp(
                step.xHint,
                curPlatLeft + 8,
                curPlatRight - 8
              );
              return {
                x: xTarget,
                y: curPlat.y - enemy.height,
                action: "drop",
              };
            }
            case "jump": {
              let xTarget = step.takeoffX;
              if (step.fromSide === "left")
                xTarget = Math.max(curPlatLeft + AI_CFG.takeoffMargin, xTarget);
              if (step.fromSide === "right")
                xTarget = Math.min(
                  curPlatRight - AI_CFG.takeoffMargin,
                  xTarget
                );
              return {
                x: xTarget,
                y: curPlat.y - enemy.height,
                action: "jump",
                side: step.fromSide,
              };
            }
            default:
              return fallbackPos || null;
          }
        }
        function reachedWaypoint(enemy, wp) {
          if (!wp) return true;
          const dx = enemy.x + enemy.width / 2 - wp.x;
          const dy = enemy.y + enemy.height / 2 - wp.y;
          return (
            Math.abs(dx) <= AI_CFG.waypointArriveDist &&
            Math.abs(dy) <= enemy.height * 0.75
          );
        }
        function queueJump(enemy, now) {
          enemy.jumpQueuedUntil = now + AI_CFG.jumpBufferMs;
        }
        function tryConsumeJump(enemy, now) {
          const canCoyote = now - enemy.lastGroundTime <= AI_CFG.coyoteMs;
          if (enemy.onGround || canCoyote) {
            if (now <= enemy.jumpQueuedUntil) {
              enemy.dy = enemy.jumpPower;
              enemy.onGround = false;
              enemy.jumpQueuedUntil = -1;
              return true;
            }
          }
          return false;
        }
        function senseGapAhead(enemy) {
          if (!enemy.currentPlatform) return false;
          const dir =
            Math.sign(enemy.dx || 0.001) ||
            Math.sign(enemy.direction === "right" ? 1 : -1) ||
            1;
          const lookX =
            dir > 0
              ? enemy.x + enemy.width + AI_CFG.edgeLookAhead
              : enemy.x - AI_CFG.edgeLookAhead;
          const plat = enemy.currentPlatform;
          if (dir > 0) return lookX >= plat.x + plat.width - 1;
          return lookX <= plat.x + 1;
        }
        function handleWallClimb(enemy, now) {
          if (enemy.onWall && enemy.wallClimb.active === false) {
            enemy.wallClimb.active = true;
            enemy.wallClimb.side = enemy.onWall;
            enemy.wallClimb.jumpsLeft = AI_CFG.maxWallJumps;
            enemy.wallClimb.lastJumpTime = now - AI_CFG.climbIntervalMs;
            enemy.climbingWall = enemy.climbingWall || { y: enemy.y };
            enemy.isVerticalClimbing = true;
            enemy.isMidClimb = true;
          }
          if (!enemy.isVerticalClimbing) return;
          if (enemy.onGround || enemy.wallClimb.jumpsLeft <= 0) {
            enemy.isVerticalClimbing = false;
            enemy.isMidClimb = false;
            enemy.wallClimb.active = false;
            enemy.wallClimb.side = null;
            enemy.wallClimb.jumpsLeft = AI_CFG.maxWallJumps;
            enemy.climbingWall = null;
            return;
          }
          if (!enemy.onWall && enemy.wallClimb.side) {
            const push = enemy.wallClimb.side === "left" ? -0.2 : 0.2;
            enemy.dx += push;
          }
          const nearApex = enemy.dy > AI_CFG.climbApexVel;
          const readyByTimer =
            now - enemy.wallClimb.lastJumpTime >= AI_CFG.climbIntervalMs;
          if ((nearApex || readyByTimer) && enemy.wallClimb.jumpsLeft > 0) {
            enemy.dy = enemy.jumpPower;
            enemy.dx =
              enemy.wallClimb.side === "left"
                ? AI_CFG.wallClimbKickX
                : -AI_CFG.wallClimbKickX;
            enemy.wallClimb.jumpsLeft--;
            enemy.wallClimb.lastJumpTime = now;
            enemy.climbDirection = enemy.wallClimb.side === "left" ? 1 : -1;
            enemy.isMidClimb = true;
            enemy.onWall = false;
          }
          if (
            enemy.climbingWall &&
            enemy.y + enemy.height < enemy.climbingWall.y
          ) {
            enemy.dx =
              enemy.climbDirection *
              (typeof DASH_SPEED !== "undefined" ? DASH_SPEED * 0.8 : 3.0);
            enemy.dy = 0;
            enemy.isMidClimb = false;
            enemy.isVerticalClimbing = false;
            enemy.wallClimb.active = false;
            enemy.wallClimb.side = null;
            enemy.wallClimb.jumpsLeft = AI_CFG.maxWallJumps;
            enemy.climbingWall = null;
          }
        }
        function steerToX(enemy, targetX) {
          const centerX = enemy.x + enemy.width / 2;
          const delta = targetX - centerX;
          const desired = clamp(delta, -enemy.maxSpeed, enemy.maxSpeed);
          const accel = enemy.onGround ? enemy.accel : enemy.airAccel;
          enemy.dx += clamp(desired - enemy.dx, -accel, accel);
          if (Math.abs(desired) < 0.05 && enemy.onGround) {
            enemy.dx *= enemy.friction;
          }
          enemy.direction =
            enemy.dx > 0.1
              ? "right"
              : enemy.dx < -0.1
              ? "left"
              : enemy.direction;
        }
        function clamp(v, min, max) {
          return Math.max(min, Math.min(max, v));
        }

        function updateAI(enemy, now) {
          ensureAIProps(enemy, now);
          const playerCenter = {
            x: player.x + player.width / 2,
            y: player.y + player.height / 2,
          };
          const enemyCenter = {
            x: enemy.x + enemy.width / 2,
            y: enemy.y + enemy.height / 2,
          };
          const seesPlayer = hasLineOfSight(enemyCenter, playerCenter);
          const horizontalDist = player.x - enemy.x;
          const totalDist = Math.hypot(horizontalDist, player.y - enemy.y);
          if (enemy.onGround) enemy.lastGroundTime = now;
          if (enemy.onWall) enemy.lastWallTime = now;
          if (seesPlayer) {
            enemy.targetPos = { ...playerCenter };
            enemy.lastKnownPlayerPos = { ...playerCenter };
            if (
              totalDist <
              (typeof AI_FLEE_DISTANCE !== "undefined" ? AI_FLEE_DISTANCE : 100)
            )
              enemy.aiState = "fleeing";
            else if (
              totalDist >
              (typeof AI_OPTIMAL_DISTANCE !== "undefined"
                ? AI_OPTIMAL_DISTANCE
                : 240)
            )
              enemy.aiState = "seeking";
            else enemy.aiState = "attacking";
          } else {
            if (enemy.aiState !== "repositioning")
              enemy.aiState = enemy.lastKnownPlayerPos
                ? "seeking"
                : "patrolling";
            if (enemy.lastKnownPlayerPos) {
              enemy.targetPos = { ...enemy.lastKnownPlayerPos };
            } else if (enemy.currentPlatform) {
              const platformMidX =
                enemy.currentPlatform.x + enemy.currentPlatform.width / 2;
              enemy.targetPos = {
                x: platformMidX + enemy.patrolDirection * 40,
                y: enemy.currentPlatform.y - enemy.height,
              };
            }
          }
          if (enemy.targetPos) {
            planPath(enemy, enemy.targetPos, now, platforms);
          }
          let waypoint = currentWaypoint(
            enemy,
            platforms,
            enemy.targetPos || null
          );
          let intentX = null;
          switch (enemy.aiState) {
            case "attacking": {
              intentX = enemy.targetPos ? enemy.targetPos.x : enemyCenter.x;
              if (now - enemy.lastShotTime > enemy.shootCooldown) {
                enemy.lastShotTime = now;
                let dx = playerCenter.x - enemyCenter.x,
                  dy = playerCenter.y - enemyCenter.y;
                const mag = Math.hypot(dx, dy) || 1,
                  bulletSpeed = 4;
                enemyPellets.push({
                  x: enemyCenter.x,
                  y: enemyCenter.y,
                  startX: enemyCenter.x,
                  startY: enemyCenter.y,
                  firedBy: enemy,
                  radius: 5,
                  dx: (dx / mag) * bulletSpeed,
                  dy: (dy / mag) * bulletSpeed,
                  color: "#f58742",
                  bounces:
                    typeof BULLET_BOUNCES !== "undefined" ? BULLET_BOUNCES : 0,
                });
                if (Math.random() < 0.6 && enemy.onGround) {
                  enemy.dy = -3;
                  enemy.dx -= Math.sign(horizontalDist) * 2;
                }
              }
              break;
            }
            case "fleeing": {
              intentX = enemyCenter.x - Math.sign(horizontalDist) * 1000;
              break;
            }
            case "seeking": {
              if (waypoint && reachedWaypoint(enemy, waypoint)) {
                enemy.nav.idx++;
                waypoint = currentWaypoint(
                  enemy,
                  platforms,
                  enemy.targetPos || null
                );
              }
              if (!waypoint) {
                if (enemy.targetPos) intentX = enemy.targetPos.x;
              } else {
                intentX = waypoint.x;
                if (waypoint.action === "jump") {
                  const close =
                    Math.abs(enemy.x + enemy.width / 2 - waypoint.x) <=
                    Math.max(12, AI_CFG.takeoffMargin + 4);
                  if (close) queueJump(enemy, now);
                }
              }
              break;
            }
            case "repositioning": {
              if (enemy.currentPlatform) {
                const left = enemy.currentPlatform.x;
                const right =
                  enemy.currentPlatform.x + enemy.currentPlatform.width;
                const distToLeft = Math.abs(enemy.x - left);
                const distToRight = Math.abs(enemy.x + enemy.width - right);
                intentX = distToLeft < distToRight ? left + 8 : right - 8;
              }
              break;
            }
            case "patrolling": {
              if (now > enemy.aiStateTimer) {
                enemy.patrolDirection *= -1;
                enemy.aiStateTimer =
                  now +
                  (typeof AI_PATROL_TIME !== "undefined"
                    ? AI_PATROL_TIME
                    : 1500);
              }
              if (enemy.currentPlatform) {
                const mid =
                  enemy.currentPlatform.x + enemy.currentPlatform.width / 2;
                intentX = mid + enemy.patrolDirection * 60;
              } else {
                intentX = enemyCenter.x + enemy.patrolDirection * 60;
              }
              break;
            }
          }
          if (
            !seesPlayer &&
            enemy.onGround &&
            player.y < enemy.y &&
            enemy.currentPlatform &&
            player.y + player.height > enemy.y
          ) {
            enemy.aiState = "repositioning";
          }
          const targetAbove =
            enemy.targetPos && enemy.targetPos.y < enemy.y - 16;
          if (enemy.onWall && targetAbove) {
            enemy.isVerticalClimbing = true;
          }
          handleWallClimb(enemy, now);
          if (enemy.onGround && intentX !== null) {
            const approachingEdge = senseGapAhead(enemy);
            if (approachingEdge) {
              queueJump(enemy, now);
            }
          }
          tryConsumeJump(enemy, now);
          if (!enemy.isVerticalClimbing) {
            if (intentX !== null) steerToX(enemy, intentX);
            else if (waypoint) steerToX(enemy, waypoint.x);
          }
          enemy.direction =
            enemy.dx > 0.1
              ? "right"
              : enemy.dx < -0.1
              ? "left"
              : enemy.direction;
        }

        // --- NEW: Boss AI ---
        function updateBoss(now) {
          if (!boss || boss.isDying) return;

          // Basic physics
          boss.dy += GRAVITY;
          let nextX = boss.x + boss.dx;
          let nextY = boss.y + boss.dy;
          boss.onGround = false;

          for (const plat of platforms) {
            if (checkCollision({ ...boss, x: nextX }, plat)) {
              if (boss.dx > 0) nextX = plat.x - boss.width;
              else if (boss.dx < 0) nextX = plat.x + plat.width;
              boss.dx = 0;
            }
            if (checkCollision({ ...boss, y: nextY }, plat)) {
              if (boss.dy > 0) {
                nextY = plat.y - boss.height;
                boss.dy = 0;
                boss.onGround = true;
              } else if (boss.dy < 0) {
                nextY = plat.y + plat.height;
                boss.dy = 0;
              }
            }
          }
          boss.x = nextX;
          boss.y = nextY;

          boss.dx *= FRICTION;

          // --- AI State Machine ---
          if (now > boss.aiTimer) {
            switch (boss.aiState) {
              case "intro":
                boss.isInvincible = false;
                boss.aiState = "idle";
                boss.aiTimer = now + 2000; // 2 seconds idle before first attack
                break;

              case "idle":
                const attacks = [
                  "teleportSlam",
                  "spiralShotgun",
                  "laserBarrage",
                  "summonMinions",
                  "charge",
                ];
                const nextAttack =
                  attacks[Math.floor(Math.random() * attacks.length)];

                boss.aiState = nextAttack;
                boss.attackPhase = 0;
                boss.aiTimer = now + 500; // Small delay before attack starts
                break;

              // --- ATTACK: Teleport Slam ---
              case "teleportSlam":
                if (boss.attackPhase === 0) {
                  // Phase 0: Vanish
                  spawnParticles(
                    boss.x + boss.width / 2,
                    boss.y + boss.height / 2,
                    50,
                    boss.color,
                    8
                  );
                  boss.isInvincible = true;
                  boss.targetPos = { x: player.x, y: player.y - 150 }; // Target above player
                  boss.aiState = "teleportSlam_reappear";
                  boss.aiTimer = now + 800;
                }
                break;
              case "teleportSlam_reappear":
                boss.x = boss.targetPos.x;
                boss.y = boss.targetPos.y;
                boss.dy = 0;
                boss.isInvincible = false;
                spawnParticles(
                  boss.x + boss.width / 2,
                  boss.y + boss.height / 2,
                  50,
                  boss.color,
                  8
                );
                boss.aiState = "teleportSlam_fall";
                boss.aiTimer = now + 200; // Short pause before falling
                break;
              case "teleportSlam_fall":
                boss.dy = 25; // SLAM
                boss.aiState = "teleportSlam_landing";
                // Timer not needed, will transition on landing
                break;
              case "teleportSlam_landing": // This state is checked when boss.onGround is true
                triggerCameraShake(300, 15);
                // Create shockwave
                for (let i = -1; i <= 1; i += 2) {
                  for (let j = 0; j < 20; j++) {
                    enemyPellets.push({
                      x: boss.x + boss.width / 2,
                      y: WORLD_HEIGHT - 25,
                      radius: 8,
                      dx: i * (5 + j * 0.5),
                      dy: 0,
                      color: "#DA70D6",
                      bounces: 0,
                      life: 40,
                      damage: 20,
                    });
                  }
                }
                boss.aiState = "idle";
                boss.aiTimer = now + 3000; // Cooldown
                break;

              // --- ATTACK: Spiral Shotgun ---
              case "spiralShotgun":
                boss.attackAngle += 0.3;
                const bulletSpeed = 5;
                enemyPellets.push({
                  x: boss.x + boss.width / 2,
                  y: boss.y + boss.height / 2,
                  radius: 6,
                  dx: Math.cos(boss.attackAngle) * bulletSpeed,
                  dy: Math.sin(boss.attackAngle) * bulletSpeed,
                  color: "#FF00FF",
                  bounces: 0,
                  life: 120,
                  damage: 10,
                });
                enemyPellets.push({
                  x: boss.x + boss.width / 2,
                  y: boss.y + boss.height / 2,
                  radius: 6,
                  dx: Math.cos(boss.attackAngle + Math.PI) * bulletSpeed,
                  dy: Math.sin(boss.attackAngle + Math.PI) * bulletSpeed,
                  color: "#FF00FF",
                  bounces: 0,
                  life: 120,
                  damage: 10,
                });

                boss.aiTimer = now + 50; // Fire every 50ms
                boss.attackPhase++;
                if (boss.attackPhase > 60) {
                  boss.aiState = "idle";
                  boss.aiTimer = now + 3000;
                }
                break;

              // --- ATTACK: Laser Barrage ---
              case "laserBarrage":
                if (boss.attackPhase < 3) {
                  const startPos = {
                    x: boss.x + boss.width / 2,
                    y: boss.y + boss.height / 2,
                  };
                  const endPos = {
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                  };
                  activeBeams.push({
                    start: startPos,
                    end: endPos,
                    endTime: now + 500,
                    alpha: 1.0,
                    color: "rgba(255, 0, 128, 0.8)",
                    width: 15,
                    damage: 25, // Add damage prop
                  });
                  boss.attackPhase++;
                  boss.aiTimer = now + 300;
                } else {
                  boss.aiState = "idle";
                  boss.aiTimer = now + 2500;
                }
                break;

              // --- ATTACK: Summon Minions ---
              case "summonMinions":
                spawnEnemies(2);
                spawnParticles(
                  boss.x + boss.width / 2,
                  boss.y + boss.height / 2,
                  60,
                  "#550055",
                  5
                );
                boss.aiState = "idle";
                boss.aiTimer = now + 4000;
                break;

              // --- ATTACK: Relentless Charge ---
              case "charge":
                if (boss.attackPhase === 0) {
                  // Wind up
                  boss.targetPos = { y: player.y }; // Lock Y position
                  boss.color = "#FF69B4"; // Hot pink to signal
                  boss.attackPhase = 1;
                  boss.aiTimer = now + 1000;
                } else {
                  boss.color = "#8B008B"; // Reset color
                  const direction = player.x > boss.x ? 1 : -1;
                  boss.dx = direction * 20;
                  boss.dy = -2; // slight hop
                  boss.y = Math.min(boss.y, boss.targetPos.y); // move to player's Y
                  boss.aiState = "idle";
                  boss.aiTimer = now + 3000;
                }
                break;
            }
          }

          // State transition based on physics (e.g., landing after slam)
          if (boss.aiState === "teleportSlam_fall" && boss.onGround) {
            boss.aiState = "teleportSlam_landing";
            boss.aiTimer = now; // Trigger landing logic immediately
          }
        }

        function updateCutscene() {
          cutsceneState.timer++;
          const timer = cutsceneState.timer;
          if (cutsceneState.stage === 0) {
            cutsceneState.letterboxHeight = Math.max(
              50,
              cutsceneState.letterboxHeight - 5
            );
            cutsceneState.textAlpha = Math.min(1, timer / 60);
            if (timer > 120) {
              cutsceneState.stage = 1;
              cutsceneState.timer = 0;
            }
          } else if (cutsceneState.stage === 1) {
            cutsceneState.textAlpha = Math.max(0, 1 - cutsceneState.timer / 30);
            if (cutsceneState.timer === 30) {
              spawnParticles(
                player.x + player.width / 2,
                player.y + player.height / 2,
                40,
                "#fff",
                5
              );
            }
            if (cutsceneState.timer > 30) {
              cutsceneState.playerAlpha = Math.min(
                1,
                (cutsceneState.timer - 30) / 60
              );
            }
            if (cutsceneState.timer > 150) {
              cutsceneState.stage = 2;
              cutsceneState.timer = 0;
            }
          } else if (cutsceneState.stage === 2) {
            cutsceneState.textAlpha = Math.min(1, cutsceneState.timer / 60);
            if (cutsceneState.timer > 120) {
              cutsceneState.stage = 3;
              cutsceneState.timer = 0;
            }
          } else if (cutsceneState.stage === 3) {
            cutsceneState.letterboxHeight += 10;
            cutsceneState.textAlpha = Math.max(0, 1 - cutsceneState.timer / 30);
            if (cutsceneState.letterboxHeight > canvas.height / 2 + 10) {
              gameState = "playing";
            }
          }
        }

        function updateCamera() {
          const targetX = player.x + player.width / 2 - camera.width / 2;
          const targetY = player.y + player.height / 2 - camera.height / 2;

          camera.x += (targetX - camera.x) * CAMERA_SMOOTH_FACTOR;
          camera.y += (targetY - camera.y) * CAMERA_SMOOTH_FACTOR;

          camera.x = Math.max(
            0,
            Math.min(camera.x, WORLD_WIDTH - camera.width)
          );
          camera.y = Math.max(
            0,
            Math.min(camera.y, WORLD_HEIGHT - camera.height)
          );
        }

        function update() {
          if (gameState === "paused" || gameState === "victory") return;

          const now = Date.now();

          worldMousePos.x = mousePos.x + camera.x;
          worldMousePos.y = mousePos.y + camera.y;

          if (impactFrameState.active) {
            if (now > impactFrameState.endTime) {
              impactFrameState.active = false;
            } else {
              return;
            }
          }

          updateCamera();

          if (gameState === "cutscene") {
            updateCutscene();
            return;
          }

          if (boss) {
            updateBoss(now);
            if (boss.health <= 0 && !boss.isDying) {
              boss.isDying = true;
              boss.deathTimer = now + 4000;
            }
            if (boss.isDying) {
              if (now < boss.deathTimer) {
                if (Math.random() < 0.5) {
                  // continuous explosions
                  spawnParticles(
                    boss.x + Math.random() * boss.width,
                    boss.y + Math.random() * boss.height,
                    10,
                    "#FFFFFF",
                    15
                  );
                  spawnParticles(
                    boss.x + Math.random() * boss.width,
                    boss.y + Math.random() * boss.height,
                    10,
                    boss.color,
                    15
                  );
                }
                if (now > boss.deathTimer - 500) triggerCameraShake(500, 20);
              } else {
                boss = null;
                bossFightActive = false;
                gameState = "victory";
                stopMusic(bossBgm);
                playMusic(bgm);
              }
            }
          }

          if (domainExpansion.isActive) {
            if (now > domainExpansion.endTime) {
              domainExpansion.isActive = false;
            } else {
              if (now - domainExpansion.lastTickTime > DOMAIN_TICK_RATE) {
                domainExpansion.lastTickTime = now;
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;

                let allTargets = enemies.slice();
                if (boss && !boss.isInvincible) allTargets.push(boss);

                allTargets.forEach((target) => {
                  if (target.isDying) return;
                  const targetCenterX = target.x + target.width / 2;
                  const targetCenterY = target.y + target.height / 2;
                  const distance = Math.hypot(
                    playerCenterX - targetCenterX,
                    playerCenterY - targetCenterY
                  );
                  if (distance <= DOMAIN_RADIUS) {
                    target.health -= DOMAIN_DAMAGE_PER_TICK;
                    createSlashEffect(targetCenterX, targetCenterY);
                    if (target.health <= 0 && !target.isDying) {
                      target.health = 0;
                      target.isDying = true;
                      target.deathTimer = now + 1000;
                    }
                  }
                });
              }
            }
          }

          // MODIFIED: Wave spawning logic
          if (
            enemies.length === 0 &&
            gameState === "playing" &&
            !bossFightActive
          ) {
            waveNumber++;
            if (waveNumber === 10) {
              spawnBoss();
            } else {
              spawnEnemies(enemyCountForSpawning);
              waveMessage = `Wave ${waveNumber}`;
              waveMessageEndTime = now + 2000;
            }
          }
          if (player.isDashing && now > player.dashEndTime)
            player.isDashing = false;
          if (player.isInvincible && now > player.invincibilityEndTime)
            player.isInvincible = false;

          if (player.isParrying && now > player.parryEndTime) {
            player.isParrying = false;
          }

          if (
            player.dashesRemaining < MAX_DASHES &&
            now > player.lastDashReplenishTime + DASH_REPLENISH_COOLDOWN
          ) {
            player.dashesRemaining++;
            player.lastDashReplenishTime = now;
          }
          if (isMouseDown) {
            const currentWeapon = player.weapons[player.currentWeaponIndex];
            if (currentWeapon === "Gun") {
              if (!PLAYER_SEMI_AUTO_FIRE) {
                shootPellet();
              }
            } else if (
              currentWeapon === "Sword" ||
              currentWeapon === "Long Sword"
            ) {
              performMeleeAttack();
            } else if (currentWeapon === "Hitscan") {
              if (!HITSCAN_SEMI_AUTO_FIRE) {
                fireHitscan();
              }
            } else if (currentWeapon === "Shotgun") {
              if (!SHOTGUN_SEMI_AUTO_FIRE) {
                fireShotgun();
              }
            }
          }

          if (activeSwordSwing) {
            const progress =
              (now - activeSwordSwing.startTime) / activeSwordSwing.duration;
            if (progress >= 1) {
              activeSwordSwing = null;
            } else {
              const swingAngle =
                activeSwordSwing.startAngle +
                (activeSwordSwing.endAngle - activeSwordSwing.startAngle) *
                  progress;

              const isLongSword = activeSwordSwing.weaponType === "Long Sword";
              const swordLength = isLongSword ? 80 : 40;
              const bladeLength = isLongSword ? 60 : 30;

              const centerX = player.x + player.width / 2;
              const centerY = player.y + player.height / 2;
              const points = [
                {
                  x:
                    centerX +
                    Math.cos(swingAngle) * (swordLength - bladeLength),
                  y:
                    centerY +
                    Math.sin(swingAngle) * (swordLength - bladeLength),
                },
                {
                  x:
                    centerX +
                    Math.cos(swingAngle) * (swordLength - bladeLength / 2),
                  y:
                    centerY +
                    Math.sin(swingAngle) * (swordLength - bladeLength / 2),
                },
                {
                  x: centerX + Math.cos(swingAngle) * swordLength,
                  y: centerY + Math.sin(swingAngle) * swordLength,
                },
              ];

              let allTargets = enemies.slice();
              if (boss && !boss.isInvincible) allTargets.push(boss);

              for (const target of allTargets) {
                if (
                  activeSwordSwing.hitTargets.includes(target) ||
                  target.isDying
                )
                  continue;
                let hit = false;
                for (const point of points) {
                  if (
                    point.x > target.x &&
                    point.x < target.x + target.width &&
                    point.y > target.y &&
                    point.y < target.y + target.height
                  ) {
                    hit = true;
                    break;
                  }
                }
                if (hit) {
                  activeSwordSwing.hitTargets.push(target);

                  const hitPointX = target.x + target.width / 2;
                  const hitPointY = target.y + target.height / 2;

                  if (isLongSword) {
                    triggerImpactFrame(IMPACT_FRAME_DURATION);
                    triggerCameraShake(250, 10);
                    spawnParticles(hitPointX, hitPointY, 50, "#ffffff", 8);
                    target.health -= LONG_SWORD_DAMAGE;
                    if (!target.name) {
                      // Don't stun boss
                      target.isStunned = true;
                      target.stunEndTime = now + STUN_DURATION * 2;
                    }
                    const dx = hitPointX - centerX;
                    const dy = hitPointY - centerY;
                    const magnitude = Math.sqrt(dx * dx + dy * dy) || 1;
                    target.dx = (dx / magnitude) * LONG_SWORD_KNOCKBACK_FORCE;
                    target.dy =
                      ((dy / magnitude) * LONG_SWORD_KNOCKBACK_FORCE) / 2 - 5;
                  } else {
                    triggerCameraShake(150, 4);
                    spawnParticles(hitPointX, hitPointY, 10, "#fff");
                    target.health -= MELEE_DAMAGE;
                    if (!target.name) {
                      target.isStunned = true;
                      target.stunEndTime = now + STUN_DURATION;
                    }
                    const dx = hitPointX - centerX;
                    const dy = hitPointY - centerY;
                    const magnitude = Math.sqrt(dx * dx + dy * dy) || 1;
                    target.dx = (dx / magnitude) * MELEE_KNOCKBACK_FORCE;
                    target.dy =
                      ((dy / magnitude) * MELEE_KNOCKBACK_FORCE) / 2 - 3;
                  }

                  if (target.health <= 0 && !target.isDying) {
                    target.health = 0;
                    target.isDying = true;
                    target.deathTimer = now + 1000;
                  }
                }
              }
            }
          }
          if (!player.isDashing) {
            if (keys["a"]) {
              player.dx = -player.speed;
              player.movementDirection = "left";
            } else if (keys["d"]) {
              player.dx = player.speed;
              player.movementDirection = "right";
            } else {
              player.dx *= FRICTION;
            }
            player.dy += GRAVITY;
            if (player.onWall && player.dy > 0 && !player.onGround)
              player.dy = WALL_SLIDE_SPEED;
          }

          player.direction =
            worldMousePos.x > player.x + player.width / 2 ? "right" : "left";

          let nextX = player.x + player.dx,
            nextY = player.y + player.dy;
          player.onGround = false;
          player.onWall = false;
          for (const plat of platforms) {
            if (checkCollision({ ...player, x: nextX }, plat)) {
              if (player.dx > 0) {
                nextX = plat.x - player.width;
                player.onWall = "right";
              } else if (player.dx < 0) {
                nextX = plat.x + plat.width;
                player.onWall = "left";
              }
              player.dx = 0;
              if (player.isDashing) player.isDashing = false;
            }
            if (checkCollision({ ...player, y: nextY }, plat)) {
              if (player.dy > 0) {
                nextY = plat.y - player.height;
                player.dy = 0;
                player.onGround = true;
                player.wallJumpsRemaining = MAX_WALL_JUMPS;
              } else if (player.dy < 0) {
                nextY = plat.y + plat.height;
                player.dy = 0;
              }
              if (player.isDashing) player.isDashing = false;
            }
          }

          // NEW: Check for collision with boss
          if (
            boss &&
            !player.isInvincible &&
            !boss.isDying &&
            checkCollision(player, boss)
          ) {
            player.health -= 25;
            triggerCameraShake(150, 8);
            player.dx = player.x - boss.x > 0 ? 8 : -8;
            player.dy = -5;
            if (player.health <= 0) resetPlayer();
          }

          player.x = nextX;
          player.y = nextY;

          if (player.x < 0) player.x = 0;
          if (player.x + player.width > WORLD_WIDTH)
            player.x = WORLD_WIDTH - player.width;
          if (player.y > WORLD_HEIGHT) resetPlayer();

          for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];

            if (enemy.isDying) {
              if (now > enemy.deathTimer) {
                spawnParticles(
                  enemy.x + enemy.width / 2,
                  enemy.y + enemy.height / 2,
                  20,
                  enemy.color,
                  4
                );
                // Last enemy logic modified to check for boss fight
                const lastEnemy = enemies.length === 1 && !bossFightActive;
                enemies.splice(i, 1);
                if (lastEnemy && Math.random() < HEALTH_PACK_DROP_CHANCE) {
                  healthPacks.push({
                    x: enemy.x,
                    y: enemy.y,
                    size: 10,
                    healAmount: 25,
                  });
                }
                continue;
              }
              continue;
            }

            if (enemy.isStunned && now > enemy.stunEndTime)
              enemy.isStunned = false;
            enemy.dy += GRAVITY;
            if (enemy.isStunned) enemy.dx *= FRICTION;
            else updateAI(enemy, now);
            if (enemy.onWall && enemy.dy > 0 && !enemy.onGround)
              enemy.dy = WALL_SLIDE_SPEED;
            let enemyNextX = enemy.x + enemy.dx,
              enemyNextY = enemy.y + enemy.dy;
            enemy.onGround = false;
            enemy.onWall = false;
            enemy.currentPlatform = null;
            if (!enemy.isMidClimb) enemy.climbingWall = null;
            for (const plat of platforms) {
              if (checkCollision({ ...enemy, x: enemyNextX }, plat)) {
                if (enemy.dx > 0) {
                  enemyNextX = plat.x - enemy.width;
                  enemy.onWall = "right";
                  enemy.climbingWall = plat;
                } else if (enemy.dx < 0) {
                  enemyNextX = plat.x + plat.width;
                  enemy.onWall = "left";
                  enemy.climbingWall = plat;
                }
                enemy.dx = 0;
              }
              if (checkCollision({ ...enemy, y: enemyNextY }, plat)) {
                if (enemy.dy > 0) {
                  enemyNextY = plat.y - enemy.height;
                  enemy.dy = 0;
                  enemy.onGround = true;
                  enemy.wallJumpsRemaining = MAX_WALL_JUMPS;
                  enemy.currentPlatform = plat;
                } else if (enemy.dy < 0) {
                  enemyNextY = plat.y + plat.height;
                  enemy.dy = 0;
                }
              }
            }

            enemy.x = enemyNextX;
            enemy.y = enemyNextY;
            if (enemy.x < 0) enemy.x = 0;
            if (enemy.x + enemy.width > WORLD_WIDTH)
              enemy.x = WORLD_WIDTH - enemy.width;
            if (enemy.y > WORLD_HEIGHT) {
              const spawnPoint = spawnPoints[i % spawnPoints.length];
              enemy.x = spawnPoint.x;
              enemy.y = spawnPoint.y;
              enemy.dx = 0;
              enemy.dy = 0;
              enemy.wallJumpsRemaining = MAX_WALL_JUMPS;
              enemy.health = enemy.maxHealth;
            }
          }

          function handlePelletUpdates(pelletArray, targets) {
            for (let i = pelletArray.length - 1; i >= 0; i--) {
              const p = pelletArray[i];
              const prevX = p.x,
                prevY = p.y;
              p.x += p.dx;
              p.y += p.dy;
              let removed = false;

              if (p.life && --p.life <= 0) {
                pelletArray.splice(i, 1);
                continue;
              }

              for (let j = targets.length - 1; j >= 0; j--) {
                const target = targets[j];
                const isPlayerTarget = target === player;

                if (target.isInvincible) continue;

                if (
                  isPlayerTarget &&
                  player.isParrying &&
                  checkCollision(
                    {
                      x: p.x - p.radius,
                      y: p.y - p.radius,
                      width: p.radius * 2,
                      height: p.radius * 2,
                    },
                    player
                  )
                ) {
                  triggerCameraShake(80, 3);
                  spawnParticles(p.x, p.y, 15, "#00ffff", 4);
                  const playerCenterX = player.x + player.width / 2;
                  const playerCenterY = player.y + player.height / 2;
                  let dx = worldMousePos.x - playerCenterX;
                  let dy = worldMousePos.y - playerCenterY;
                  const magnitude = Math.sqrt(dx * dx + dy * dy) || 1;
                  const bulletSpeed = 10;
                  pellets.push({
                    x: p.x,
                    y: p.y,
                    dx: (dx / magnitude) * bulletSpeed,
                    dy: (dy / magnitude) * bulletSpeed,
                    radius: 5,
                    color: "#00ffff",
                    bounces: BULLET_BOUNCES,
                    damage: p.damage * 2, // Parry reflects with more damage!
                  });
                  pelletArray.splice(i, 1);
                  removed = true;
                  break;
                }

                if (!isPlayerTarget && target.isDying) {
                  continue;
                }

                if (p.firedBy && p.firedBy === target) {
                  const distSq = (p.x - p.startX) ** 2 + (p.y - p.startY) ** 2;
                  if (distSq < ENEMY_PROJECTILE_ARMING_DISTANCE ** 2) {
                    continue;
                  }
                }

                if (
                  checkCollision(
                    {
                      x: p.x - p.radius,
                      y: p.y - p.radius,
                      width: p.radius * 2,
                      height: p.radius * 2,
                    },
                    target
                  )
                ) {
                  target.health -= p.damage || 10;
                  if (!isPlayerTarget)
                    spawnParticles(p.x, p.y, 5, target.color || "#ff0000");
                  else triggerCameraShake(100, 2);

                  if (target.health <= 0 && !target.isDying) {
                    if (isPlayerTarget) {
                      resetPlayer();
                    } else {
                      target.health = 0;
                      target.isDying = true;
                      target.deathTimer = now + 1000;
                    }
                  }
                  pelletArray.splice(i, 1);
                  removed = true;
                  break;
                }
              }
              if (removed) continue;
              for (const plat of platforms) {
                if (
                  checkCollision(
                    {
                      x: p.x - p.radius,
                      y: p.y - p.radius,
                      width: p.radius * 2,
                      height: p.radius * 2,
                    },
                    plat
                  )
                ) {
                  spawnParticles(p.x, p.y, 3, "#fafafa");
                  if (p.bounces-- <= 0) {
                    pelletArray.splice(i, 1);
                    removed = true;
                    break;
                  }
                  const p_bottom = prevY + p.radius,
                    p_top = prevY - p.radius;
                  if (p_bottom <= plat.y || p_top >= plat.y + plat.height)
                    p.dy *= -1;
                  else p.dx *= -1;
                  p.x = prevX;
                  p.y = prevY;
                  break;
                }
              }
              if (removed) continue;
              if (p.x < 0 || p.x > WORLD_WIDTH || p.y < 0 || p.y > WORLD_HEIGHT)
                pelletArray.splice(i, 1);
            }
          }

          let playerPelletTargets = enemies.slice();
          if (boss && !boss.isInvincible) playerPelletTargets.push(boss);
          handlePelletUpdates(pellets, playerPelletTargets);

          const enemyPelletTargets = ENEMY_FRIENDLY_FIRE
            ? [player, ...enemies]
            : [player];
          handlePelletUpdates(enemyPellets, enemyPelletTargets);

          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.dx;
            p.y += p.dy;
            p.dx *= 0.95;
            p.dy *= 0.95;
            p.dy += GRAVITY * 0.1;
            if (--p.life <= 0) particles.splice(i, 1);
          }
          for (let i = slashEffects.length - 1; i >= 0; i--) {
            const effect = slashEffects[i];
            effect.life--;
            effect.alpha = effect.life / 15;
            if (effect.life <= 0) {
              slashEffects.splice(i, 1);
            }
          }
          for (let i = activeBeams.length - 1; i >= 0; i--) {
            const beam = activeBeams[i];

            // NEW: Laser beam damage check
            if (
              beam.damage &&
              !player.isInvincible &&
              lineIntersectsRect(beam.start, beam.end, player)
            ) {
              player.health -= beam.damage;
              beam.damage = 0; // Deal damage only once
              triggerCameraShake(150, 10);
              if (player.health <= 0) resetPlayer();
            }

            if (now > beam.endTime) {
              activeBeams.splice(i, 1);
            } else {
              beam.alpha =
                (beam.endTime - now) / (beam.endTime - (beam.startTime || now));
            }
          }
          for (let i = healthPacks.length - 1; i >= 0; i--) {
            const pack = healthPacks[i];
            if (
              checkCollision(player, {
                x: pack.x,
                y: pack.y,
                width: pack.size,
                height: pack.size,
              })
            ) {
              player.health = Math.min(
                player.maxHealth,
                player.health + pack.healAmount
              );
              spawnParticles(pack.x, pack.y, 10, "#2ecc71");
              healthPacks.splice(i, 1);
            }
          }
        }

        function drawCutscene() {
          ctx.fillStyle = "#87ceeb";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.save();
          ctx.translate(-camera.x, -camera.y);

          ctx.fillStyle = "#654321";
          for (const plat of platforms)
            ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
          ctx.globalAlpha = cutsceneState.playerAlpha;
          if (player.isInvincible)
            ctx.fillStyle = `rgba(255, 255, 255, ${
              0.6 + Math.sin(Date.now() / 80) * 0.4
            })`;
          else if (player.onWall) ctx.fillStyle = "#ffff99";
          else ctx.fillStyle = player.color;
          ctx.fillRect(player.x, player.y, player.width, player.height);
          ctx.globalAlpha = 1;
          for (const p of particles) {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
          }

          ctx.restore();

          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, canvas.width, cutsceneState.letterboxHeight);
          ctx.fillRect(
            0,
            canvas.height - cutsceneState.letterboxHeight,
            canvas.width,
            cutsceneState.letterboxHeight
          );
          ctx.textAlign = "center";
          ctx.globalAlpha = cutsceneState.textAlpha;
          if (cutsceneState.stage < 2) {
            ctx.font = "bold 32px 'Courier New', monospace";
            ctx.fillStyle = "#fff";
            ctx.fillText("Wave 1", canvas.width / 2, canvas.height / 2);
          } else if (cutsceneState.stage === 2) {
            ctx.font = "bold 48px 'Courier New', monospace";
            ctx.fillStyle = "#ff0";
            ctx.fillText("GET READY!", canvas.width / 2, canvas.height / 2);
          }
          ctx.globalAlpha = 1;
          if (gameState === "cutscene" && cutsceneState.stage < 3) {
            ctx.font = "14px 'Courier New', monospace";
            ctx.fillStyle = "#fff";
            ctx.fillText(
              "Press any key to skip",
              canvas.width / 2,
              canvas.height - 15
            );
          }
        }

        function drawSword(centerX, centerY, angle, length = 40) {
          const handleLength = 10;
          const crossguardWidth = 16;
          const bladeLength = length - handleLength;

          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          ctx.fillStyle = "#654321";
          ctx.fillRect(0, -2, handleLength, 4);
          ctx.fillStyle = "#888";
          ctx.fillRect(
            handleLength - 2,
            -crossguardWidth / 2,
            4,
            crossguardWidth
          );
          ctx.fillStyle = "#ddd";
          ctx.fillRect(handleLength, -2, bladeLength, 4);
          ctx.restore();
        }

        function drawGun(centerX, centerY, angle) {
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          ctx.fillStyle = "#555";
          ctx.fillRect(0, -3, 20, 6);
          ctx.fillStyle = "#333";
          ctx.fillRect(0, 3, 5, 2); // MODIFIED
          ctx.restore();
        }

        function drawHitscan(centerX, centerY, angle) {
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          ctx.fillStyle = "#777";
          ctx.fillRect(0, -2, 25, 4);
          ctx.fillStyle = "yellow";
          ctx.fillRect(25, -1, 5, 2);
          ctx.restore();
        }

        function drawShotgun(centerX, centerY, angle) {
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          ctx.fillStyle = "#8B4513"; // Brown for wood stock
          ctx.fillRect(0, -4, 15, 8);
          ctx.fillStyle = "#666"; // Grey for barrel
          ctx.fillRect(15, -3, 15, 6);
          ctx.restore();
        }

        function drawRailcannon(centerX, centerY, angle) {
          const length = 40;
          const width = 12;

          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);

          // Main body
          ctx.fillStyle = "#444";
          ctx.fillRect(0, -width / 2, length, width);

          // Barrel
          ctx.fillStyle = "#222";
          ctx.fillRect(length, -width / 4, 10, width / 2);

          // Energy coils
          const now = Date.now();
          let coilColor = "#888";
          if (now > player.railcannonCooldownEndTime) {
            coilColor = `hsl(60, 100%, ${60 + Math.sin(now / 100) * 15}%)`;
          } else {
            const cooldownProgress =
              1 -
              (player.railcannonCooldownEndTime - now) / RAILCANNON_COOLDOWN;
            coilColor = `hsl(0, 100%, ${20 + 30 * cooldownProgress}%)`;
          }
          ctx.fillStyle = coilColor;
          ctx.fillRect(5, -width / 2 - 2, length - 10, 2);
          ctx.fillRect(5, width / 2, length - 10, 2);

          ctx.restore();
        }

        function draw() {
          ctx.save();

          if (Date.now() < cameraShake.endTime && !impactFrameState.active) {
            const dx = (Math.random() - 0.5) * cameraShake.magnitude,
              dy = (Math.random() - 0.5) * cameraShake.magnitude;
            ctx.translate(dx, dy);
          }

          ctx.fillStyle = "#87ceeb";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          if (gameState === "cutscene") {
            drawCutscene();
            ctx.restore();
            return;
          }

          ctx.save();
          ctx.translate(-camera.x, -camera.y);

          if (domainExpansion.isActive) {
            ctx.fillStyle = "rgba(20, 0, 0, 0.6)";
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

            const drawTorii = (x, y, scale, alpha) => {
              ctx.save();
              ctx.fillStyle = `rgba(50, 0, 0, ${alpha})`;
              ctx.strokeStyle = `rgba(100, 10, 10, ${alpha})`;
              ctx.lineWidth = 4 * scale;
              ctx.beginPath();
              ctx.moveTo(x - 70 * scale, y - 60 * scale);
              ctx.bezierCurveTo(
                x - 60 * scale,
                y - 80 * scale,
                x + 60 * scale,
                y - 80 * scale,
                x + 70 * scale,
                y - 60 * scale
              );
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(x - 60 * scale, y - 40 * scale);
              ctx.lineTo(x + 60 * scale, y - 40 * scale);
              ctx.stroke();
              ctx.fillRect(
                x - 50 * scale,
                y - 60 * scale,
                10 * scale,
                120 * scale
              );
              ctx.fillRect(
                x + 40 * scale,
                y - 60 * scale,
                10 * scale,
                120 * scale
              );
              ctx.restore();
            };
            drawTorii(WORLD_WIDTH / 2, WORLD_HEIGHT / 2 + 50, 1.5, 0.4);
            drawTorii(150, 100, 0.8, 0.3);
            drawTorii(1500, WORLD_HEIGHT - 300, 1.0, 0.2);
          }

          // NEW: Boss Arena tint
          if (bossFightActive) {
            ctx.fillStyle = "rgba(100, 0, 20, 0.15)";
            ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
          }

          ctx.fillStyle = "#654321";
          for (const plat of platforms)
            ctx.fillRect(plat.x, plat.y, plat.width, plat.height);

          for (const pack of healthPacks) {
            ctx.fillStyle = "#2ecc71";
            ctx.fillRect(pack.x, pack.y, pack.size, pack.size);
            ctx.fillStyle = "#fff";
            ctx.fillRect(
              pack.x + pack.size / 2 - 1,
              pack.y + 2,
              2,
              pack.size - 4
            );
            ctx.fillRect(
              pack.x + 2,
              pack.y + pack.size / 2 - 1,
              pack.size - 4,
              2
            );
          }

          if (showPaths) {
            for (const enemy of enemies) {
              if (enemy.pathPrediction && enemy.pathPrediction.length > 0) {
                ctx.beginPath();
                ctx.moveTo(
                  enemy.x + enemy.width / 2,
                  enemy.y + enemy.height / 2
                );

                for (const point of enemy.pathPrediction) {
                  ctx.lineTo(
                    point.x + enemy.width / 2,
                    point.y + enemy.height / 2
                  );
                }

                ctx.strokeStyle = enemy.isVerticalClimbing
                  ? "#ff00ff"
                  : "#00ffff";
                ctx.lineWidth = 1;
                ctx.stroke();

                if (enemy.targetPos) {
                  ctx.beginPath();
                  ctx.arc(
                    enemy.targetPos.x,
                    enemy.targetPos.y,
                    5,
                    0,
                    Math.PI * 2
                  );
                  ctx.fillStyle = "#ff0000";
                  ctx.fill();
                }
              }
            }
          }

          // --- NEW: Draw Boss ---
          if (boss && !boss.isDying) {
            if (
              boss.aiState === "teleportSlam" ||
              boss.aiState === "teleportSlam_reappear"
            ) {
              // Don't draw boss when teleporting
            } else {
              ctx.fillStyle = boss.isInvincible ? "#cccccc" : boss.color;
              ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
              // Simple eye
              const eyeX = boss.x + (player.x > boss.x ? boss.width - 15 : 5);
              ctx.fillStyle = "white";
              ctx.fillRect(eyeX, boss.y + 15, 10, 10);
              ctx.fillStyle = "black";
              ctx.fillRect(eyeX + 3, boss.y + 18, 4, 4);
            }
          }

          for (const enemy of enemies) {
            const barWidth = 30,
              barHeight = 5,
              barX = enemy.x + enemy.width / 2 - barWidth / 2,
              barY = enemy.y - 10;
            ctx.fillStyle = "#550000";
            ctx.fillRect(barX, barY, barWidth, barHeight);
            ctx.fillStyle = "#00ff00";
            ctx.fillRect(
              barX,
              barY,
              barWidth * (enemy.health / enemy.maxHealth),
              barHeight
            );
            let enemyColor = enemy.color;
            if (enemy.isStunned) enemyColor = "#800080";
            else if (enemy.isVerticalClimbing) enemyColor = "#ff00ff";
            else if (enemy.onWall) enemyColor = "#ff9999";
            ctx.fillStyle = enemyColor;
            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            if (showPaths) {
              ctx.font = "8px 'Courier New', monospace";
              ctx.fillStyle = "#fff";
              ctx.textAlign = "center";
              ctx.fillText(
                enemy.aiState,
                enemy.x + enemy.width / 2,
                enemy.y - 15
              );
            }
          }

          const playerCenterX = player.x + player.width / 2;
          const playerCenterY = player.y + player.height / 2;

          if (player.isInvincible)
            ctx.fillStyle = `rgba(255, 255, 255, ${
              0.6 + Math.sin(Date.now() / 80) * 0.4
            })`;
          else if (activeSwordSwing) ctx.fillStyle = "#ccc";
          else if (player.onWall) ctx.fillStyle = "#ffff99";
          else ctx.fillStyle = player.color;
          ctx.fillRect(player.x, player.y, player.width, player.height);

          if (player.isParrying) {
            const parryProgress =
              1 - (player.parryEndTime - Date.now()) / PARRY_DURATION;
            const radius = player.width * (1 + parryProgress * 0.5);
            const alpha = 1 - parryProgress;
            ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * 0.8})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(playerCenterX, playerCenterY, radius, 0, Math.PI * 2);
            ctx.stroke();
          }

          const currentWeapon = player.weapons[player.currentWeaponIndex];
          const dxToMouse = worldMousePos.x - playerCenterX;
          const dyToMouse = worldMousePos.y - playerCenterY;
          const aimAngle = Math.atan2(dyToMouse, dxToMouse);

          if (currentWeapon === "Sword" || currentWeapon === "Long Sword") {
            const isLongSword = currentWeapon === "Long Sword";
            const swordLength = isLongSword ? 80 : 40;

            if (activeSwordSwing) {
              const progress =
                (Date.now() - activeSwordSwing.startTime) /
                activeSwordSwing.duration;
              const currentAngle =
                activeSwordSwing.startAngle +
                (activeSwordSwing.endAngle - activeSwordSwing.startAngle) *
                  progress;
              drawSword(
                playerCenterX,
                playerCenterY,
                currentAngle,
                swordLength
              );
            } else {
              drawSword(playerCenterX, playerCenterY, aimAngle, swordLength);
            }
          } else if (currentWeapon === "Railcannon") {
            drawRailcannon(playerCenterX, playerCenterY, aimAngle);
          } else if (currentWeapon === "Gun") {
            drawGun(playerCenterX, playerCenterY, aimAngle);
          } else if (currentWeapon === "Hitscan") {
            drawHitscan(playerCenterX, playerCenterY, aimAngle);
          } else if (currentWeapon === "Shotgun") {
            drawShotgun(playerCenterX, playerCenterY, aimAngle);
          }

          for (const p of particles) {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
          }
          for (const effect of slashEffects) {
            ctx.save();
            ctx.translate(effect.x, effect.y);
            ctx.rotate(effect.angle);
            ctx.beginPath();
            ctx.moveTo(-effect.length / 2, 0);
            ctx.lineTo(effect.length / 2, 0);
            ctx.strokeStyle = `rgba(255, 20, 20, ${effect.alpha})`;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
          }
          for (const p of pellets.concat(enemyPellets)) {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.lineCap = "round";
          for (const beam of activeBeams) {
            const isRailcannon = beam.width === 20;
            ctx.beginPath();
            ctx.moveTo(beam.start.x, beam.start.y);
            ctx.lineTo(beam.end.x, beam.end.y);
            if (isRailcannon) {
              // Outer glow for railcannon
              ctx.strokeStyle = `rgba(0, 255, 255, ${beam.alpha * 0.5})`;
              ctx.lineWidth = 20;
              ctx.stroke();
              // Inner core for railcannon
              ctx.beginPath();
              ctx.moveTo(beam.start.x, beam.start.y);
              ctx.lineTo(beam.end.x, beam.end.y);
              ctx.strokeStyle = `rgba(255, 255, 255, ${beam.alpha})`;
              ctx.lineWidth = 8;
              ctx.stroke();
            } else {
              // Simpler beam for hitscan
              ctx.strokeStyle = beam.color;
              ctx.lineWidth = beam.width;
              ctx.stroke();
            }
          }
          ctx.lineCap = "butt";

          if (domainExpansion.isActive) {
            const now = Date.now();
            const pulse = Math.sin(now / 200) * 10;
            ctx.strokeStyle = `rgba(139, 0, 0, 0.8)`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(
              playerCenterX,
              playerCenterY,
              DOMAIN_RADIUS + pulse,
              0,
              Math.PI * 2
            );
            ctx.stroke();
            ctx.fillStyle = `rgba(139, 0, 0, 0.1)`;
            ctx.fill();
          }

          ctx.restore();

          // --- UI / HUD DRAWING ---
          if (screenFlash.alpha > 0) {
            ctx.fillStyle = `rgba(255, 255, 255, ${screenFlash.alpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!impactFrameState.active) {
              screenFlash.alpha -= screenFlash.decay;
            }
          }

          // --- NEW: BOSS HEALTH BAR ---
          if (boss) {
            const barWidth = canvas.width - 80;
            const barHeight = 20;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = 15;

            ctx.font = "bold 16px 'Courier New', monospace";
            ctx.textAlign = "center";
            ctx.fillStyle = "#fff";
            ctx.fillText(boss.name, canvas.width / 2, barY + barHeight + 15);

            ctx.fillStyle = "#550000";
            ctx.fillRect(barX, barY, barWidth, barHeight);

            const healthPercentage = Math.max(0, boss.health / boss.maxHealth);
            ctx.fillStyle = "#ff0000";
            ctx.fillRect(barX, barY, barWidth * healthPercentage, barHeight);

            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
          }

          const hudHeight = 205;
          const hudWidth = 220,
            margin = 10,
            padding = 10;
          const hudX = canvas.width - hudWidth - margin,
            hudY = margin;
          ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
          ctx.fillRect(hudX, hudY, hudWidth, hudHeight);
          ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
          ctx.lineWidth = 2;
          ctx.strokeRect(hudX, hudY, hudWidth, hudHeight);
          ctx.fillStyle = "#fff";
          ctx.font = "14px 'Courier New', Courier, monospace";
          ctx.textAlign = "left";
          const currentWeaponName = player.weapons[player.currentWeaponIndex];
          ctx.fillText(
            `Weapon: ${currentWeaponName}`,
            hudX + padding,
            hudY + padding + 12
          );

          if (currentWeaponName === "Long Sword") {
            const now = Date.now();
            if (now < player.longSwordCooldownEndTime) {
              const secondsLeft = (
                (player.longSwordCooldownEndTime - now) /
                1000
              ).toFixed(1);
              ctx.fillStyle = "#ff9999";
              ctx.fillText(
                `Cooldown: ${secondsLeft}s`,
                hudX + padding + 10,
                hudY + padding + 30
              );
            } else {
              ctx.fillStyle = "#99ff99";
              ctx.fillText(`Ready!`, hudX + padding + 10, hudY + padding + 30);
            }
          }
          ctx.fillStyle = "#fff";

          const barWidth = 120,
            barHeight = 15;
          const barX = hudX + 80,
            barY = hudY + padding + 40;
          const healthPercentage = Math.max(
            0,
            player.health / player.maxHealth
          );
          ctx.fillText("Health", hudX + padding, barY + barHeight - 2);
          ctx.fillStyle = "#555";
          ctx.fillRect(barX, barY, barWidth, barHeight);
          ctx.fillStyle = "#2ecc71";
          ctx.fillRect(barX, barY, barWidth * healthPercentage, barHeight);
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 1;
          ctx.strokeRect(barX, barY, barWidth, barHeight);
          ctx.fillStyle = "#fff";
          ctx.fillText(
            `Jumps: ${player.wallJumpsRemaining}`,
            hudX + padding,
            hudY + padding + 80
          );
          ctx.fillText("Dashes:", hudX + padding, hudY + padding + 100);
          const dashBoxSize = 12,
            dashBoxSpacing = 5;
          for (let i = 0; i < MAX_DASHES; i++) {
            const dashBoxX = hudX + 80 + i * (dashBoxSize + dashBoxSpacing);
            const dashBoxY = hudY + padding + 100 - dashBoxSize / 1.5;
            ctx.fillStyle = i < player.dashesRemaining ? "#3498db" : "#555";
            ctx.fillRect(dashBoxX, dashBoxY, dashBoxSize, dashBoxSize);
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(dashBoxX, dashBoxY, dashBoxSize, dashBoxSize);
          }

          ctx.fillText("Parry:", hudX + padding, hudY + padding + 120);
          const now = Date.now();
          const parryBoxX = hudX + 80;
          const parryBoxY = hudY + padding + 120 - dashBoxSize / 1.5;

          if (now < player.parryCooldownEndTime) {
            const cooldownProgress =
              1 - (player.parryCooldownEndTime - now) / PARRY_COOLDOWN;
            ctx.fillStyle = "#555";
            ctx.fillRect(parryBoxX, parryBoxY, barWidth - 30, dashBoxSize);
            ctx.fillStyle = "#f39c12";
            ctx.fillRect(
              parryBoxX,
              parryBoxY,
              (barWidth - 30) * cooldownProgress,
              dashBoxSize
            );
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(parryBoxX, parryBoxY, barWidth - 30, dashBoxSize);
          } else {
            ctx.fillStyle = "#00ffff";
            ctx.fillRect(parryBoxX, parryBoxY, dashBoxSize, dashBoxSize);
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(parryBoxX, parryBoxY, dashBoxSize, dashBoxSize);
            ctx.fillStyle = "#fff";
            ctx.fillText(
              "Ready",
              parryBoxX + dashBoxSize + 5,
              parryBoxY + dashBoxSize - 2
            );
          }

          ctx.fillText("Domain (G):", hudX + padding, hudY + padding + 140);
          const domainBoxX = hudX + 80;
          const domainBoxY = hudY + padding + 140 - dashBoxSize / 1.5;

          if (now < player.domainCooldownEndTime) {
            if (domainExpansion.isActive) {
              const durationProgress =
                (domainExpansion.endTime - now) / DOMAIN_DURATION;
              ctx.fillStyle = "#555";
              ctx.fillRect(domainBoxX, domainBoxY, barWidth - 30, dashBoxSize);
              ctx.fillStyle = "#ff0000";
              ctx.fillRect(
                domainBoxX,
                domainBoxY,
                (barWidth - 30) * durationProgress,
                dashBoxSize
              );
            } else {
              const cooldownProgress =
                1 - (player.domainCooldownEndTime - now) / DOMAIN_COOLDOWN;
              ctx.fillStyle = "#555";
              ctx.fillRect(domainBoxX, domainBoxY, barWidth - 30, dashBoxSize);
              ctx.fillStyle = "#800080";
              ctx.fillRect(
                domainBoxX,
                domainBoxY,
                (barWidth - 30) * cooldownProgress,
                dashBoxSize
              );
            }
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(domainBoxX, domainBoxY, barWidth - 30, dashBoxSize);
          } else {
            ctx.fillStyle = "#8B0000";
            ctx.fillRect(domainBoxX, domainBoxY, dashBoxSize, dashBoxSize);
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(domainBoxX, domainBoxY, dashBoxSize, dashBoxSize);
            ctx.fillStyle = "#fff";
            ctx.fillText(
              "Ready",
              domainBoxX + dashBoxSize + 5,
              domainBoxY + dashBoxSize - 2
            );
          }

          ctx.fillText("Railcannon:", hudX + padding, hudY + padding + 160);
          const railcannonBoxX = hudX + 95;
          const railcannonBoxY = hudY + padding + 160 - dashBoxSize / 1.5;
          const railcannonBarWidth = barWidth - 45;

          if (now < player.railcannonCooldownEndTime) {
            const cooldownProgress =
              1 -
              (player.railcannonCooldownEndTime - now) / RAILCANNON_COOLDOWN;
            ctx.fillStyle = "#555";
            ctx.fillRect(
              railcannonBoxX,
              railcannonBoxY,
              railcannonBarWidth,
              dashBoxSize
            );
            ctx.fillStyle = "#f1c40f";
            ctx.fillRect(
              railcannonBoxX,
              railcannonBoxY,
              railcannonBarWidth * cooldownProgress,
              dashBoxSize
            );
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(
              railcannonBoxX,
              railcannonBoxY,
              railcannonBarWidth,
              dashBoxSize
            );
          } else {
            ctx.fillStyle = "#f1c40f";
            ctx.fillRect(
              railcannonBoxX,
              railcannonBoxY,
              dashBoxSize,
              dashBoxSize
            );
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(
              railcannonBoxX,
              railcannonBoxY,
              dashBoxSize,
              dashBoxSize
            );
            ctx.fillStyle = "#fff";
            ctx.fillText(
              "Ready",
              railcannonBoxX + dashBoxSize + 5,
              railcannonBoxY + dashBoxSize - 2
            );
          }

          const enemyText = bossFightActive
            ? `Minions: ${enemies.length}`
            : `Enemies: ${enemyCountForSpawning} (N/M)`;
          ctx.fillText(enemyText, hudX + padding, hudY + padding + 180);

          if (showPaths) {
            ctx.fillStyle = "#fff";
            ctx.textAlign = "left";
            ctx.font = "12px 'Courier New', monospace";
            ctx.fillText(
              "Path Visualization ON (Press P to toggle)",
              10,
              canvas.height - 10
            );
          }

          if (Date.now() < waveMessageEndTime) {
            ctx.font = "bold 32px 'Courier New', monospace";
            ctx.textAlign = "center";
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillText(waveMessage, canvas.width / 2, canvas.height / 3);
          }

          if (gameState === "paused") {
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "#fff";
            ctx.font = "bold 48px 'Courier New', monospace";
            ctx.textAlign = "center";
            ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 2 - 20);

            ctx.font = "20px 'Courier New', monospace";
            ctx.fillText(
              "Press ESC to Resume",
              canvas.width / 2,
              canvas.height / 2 + 20
            );
          }
          // --- NEW: Victory Screen ---
          if (gameState === "victory") {
            ctx.fillStyle = "rgba(0, 50, 100, 0.8)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "#FFFF00";
            ctx.font = "bold 48px 'Courier New', monospace";
            ctx.textAlign = "center";
            ctx.fillText("VICTORY!", canvas.width / 2, canvas.height / 2 - 20);

            ctx.fillStyle = "#FFFFFF";
            ctx.font = "20px 'Courier New', monospace";
            ctx.fillText(
              "Dingus the Third has been defeated!",
              canvas.width / 2,
              canvas.height / 2 + 20
            );
            ctx.fillText(
              "Thanks for playing!",
              canvas.width / 2,
              canvas.height / 2 + 50
            );
          }

          const cursorSize = 10;
          ctx.strokeStyle = "rgba(0, 0, 0, 0.8)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(mousePos.x - cursorSize, mousePos.y);
          ctx.lineTo(mousePos.x + cursorSize, mousePos.y);
          ctx.moveTo(mousePos.x, mousePos.y - cursorSize);
          ctx.lineTo(mousePos.x, mousePos.y + cursorSize);
          ctx.stroke();

          ctx.restore();
        }

        function loop() {
          update();
          draw();
          requestAnimationFrame(loop);
        }

        loop();
      })();
    </script>
  </body>
</html>
